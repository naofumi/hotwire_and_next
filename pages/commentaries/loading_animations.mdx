import MDXRenderer from "../../components/MDXRenderer";
import CommentaryLayout from "../../components/CommentaryLayout";
import H2WithHash from "../../components/H2WithHash";
import Image from "next/image";
import netscapeImage from "../../public/images/netscape.gif"
import mosaicImage from "../../public/images/mosaic.gif"

下記のビデオは2024年8月に記録したNewsPicks社のウェブサイトです。Next.jsのSSRとGraphQLを使って作成されているようです。しかしUX上の大きな問題があります。

下記ビデオをご覧になっていただくとわかりますが、**ボタンをクリックしても全くフィードバックがなく**、1秒後ぐらいにやっと画面が切り替わります。ユーザは自分がちゃんとクリックしたかどうかに自信が持てず、不安になります。またサイト全体がモッサリしている感覚があります。

同じことはTurbo FramesやTurbo Streamsを使っている場合も起こります。ここでは問題の原因を解説し、解決策を紹介します。

<video width="733" height="606" muted autoPlay controls loop className="my-8">
  <source src="/videos/newspicks.mov" type="video/mp4"></source>
</video>


<H2WithHash id="create-tabbed-menus-with-turbo-frames">Ajax/fetchではローディングアニメーションは表示されない</H2WithHash>

ウェブブラウザは30年前からローディングアニメーションを表示していました。これはページのデータが読み込まれている間、「ちゃんと働いているよ」の合図となり、特にネットワークが非常に遅かった時代には必須なUI要素でした。

現在でも主要なブラウザはいずれもこのようなローディングアニメーションを用意しています。以前ほどは目立ちませんが、ブラウザが動いているのかどうかは明確にわかります。

<div className="flex flex-wrap gap-2">
  <Image src={netscapeImage} className="w-24"></Image>
  <Image src={mosaicImage} className="w-24"></Image>
</div>

しかしこの**ローディングアニメーションは、Ajax/fetchを使った場合には表示されません**。ブラウザは自動的にアニメーションを稼働させないのです。

**開発者が意識してローディングアニメーションを設ける必要があります。** それを忘れると先ほどのNewspicksサイトのようなUXになってしまいます。

<H2WithHash id="loading-animations-with-native">ブラウザネイティブなMPAの場合</H2WithHash>

ブラウザネイティブなMPAの場合、30年前からローディングアニメーションが用意されています。

これを確認するには、まず[トップ画面最上部](/)で遅延(delay)を2000msに設定し、[ブラウザネイティブ(MPA)画面遷移のデモ画面](/api/hotwire/users?native=true)に移動してください。画面下部の「...へ遷移(Turbo Off)」のボタンをクリックすると、ブラウザネイティブの画面遷移をご確認いただけます。その時にブラウザネイティブのローディングアニメーションが表示されることをご確認ください。(Safariだったらロケーションバーの下部を青い線が横ぎります。Chromeの場合はタブのfaviconのところが回転アニメーションになります)

<H2WithHash id="loading-animations-with-turbo-drive">Turbo Driveの場合</H2WithHash>

Turbo Driveの場合はネイティブのMPAと非常によく似たローディングアニメーションがデフォルトで用意されています。

これを確認するには、まず[トップ画面最上部](/)で遅延(delay)を2000msに設定し、[Turbo Drive画面遷移遷移のデモ画面](/api/hotwire/users)に移動してください。画面下部の「...へ遷移(Turbo On)」のボタンをクリックすると、Turbo Driveの画面遷移をご確認いただけます。ローディングアニメーションはページコンテンツの最上部を横切る青い線になります。これはTurboが用意してくれているもので、[スタイルのカスタマイズ](https://turbo.hotwired.dev/handbook/drive#displaying-progress)が可能です。

<H2WithHash id="loading-animations-with-ssr">Next.js Pages Router SSRの場合</H2WithHash>

いよいよ一番最初で紹介したNewsPicksの問題の話です。

これを確認するには、まず[トップ画面最上部](/)で遅延(delay)を2000msに設定し、[Next.js Pages Router SSR画面遷移](/users_ssr)に移動してください。画面下部の「...へSSR(アニメーションを隠す)」ボタンをクリックすると、Next.js Pages Router SSRの画面遷移をご確認いただけます。

　ボタンをクリックしてもフィードバックがなく、ウェブサイトが反応しているかどうかが全く確認できません。2000ms後にページが切り替わり、初めて正しく反応してくれたことがわかります。ユーザは操作していても自信が持てず、全体に反応が鈍く、モッサリした印象を与えます。

隣の「...へSSR」ボタン((アニメーションを隠すの表示がない方)を押すと、今後は画面右上にローディングアニメーションが表示されます。これは`components/LoadingIndicator.tsx` ([GitHub](https://github.com/naofumi/hotwire_and_next/blob/bbdb8989d166cd95fc67cec81273921d8e84b5f6/components/LoadingIndicator.tsx))の`LoadingIndicator`コンポーネントで実装しています。下記に示したようにNext.jsの`routeChangeStart`、`routeChangeComplete`イベントに反応してローダーを表示する仕組みになっています。

**components/LoadingIndicator.tsx**
```javascript
...
router.events.on('routeChangeStart', handleRouteChangeStart)
router.events.on('routeChangeComplete', handleRouteChangeComplete)
...
```

また下記のようにイベントハンドラの中では500msの遅延をさせています。ローディングアニメーションはすぐに表示するのではなく、500msを置いてから表示しています。サーバからレスポンスが500ms以内に返ってきた場合にいちいちアニメーションを表示していると却ってうるさく感じてしまうので、その場合は何も表示させないようになっています。これは[Turbo Drive](/commentaries/loading_animations#loading-animations-with-turbo-drive)のにUXを合わせています。

**components/LoadingIndicator.tsx**
```javascript
let abort = false
const handleRouteChangeStart = async (url: any, {shallow}: any) => {
  await sleep(500)
  !abort && setIsLoading(true);
}
```

実際に体感していただければわかるように、サーバからのレスポンスが遅い場合、ローディングアニメーションの追加はUXを大きく改善させます。Turbo Driveはデフォルトでアニメーションを用意してくれますが、Next.jsの場合は手間がかかります。NewsPicksのようなUXでも大丈夫かどうか、カスタムでローディングアニメーションのコードを書いてかつメンテナンスするべきかを評価する必要があるでしょう。


<H2WithHash id="turboframes">Turbo Framesの場合</H2WithHash>

Turbo Driveではデフォルトで[ローディングアニメーションが表示されます](/commentaries/loading_animations#loading-animations-with-turbo-drive)が、Turbo Framesの場合は表示されません。Turbo Frameが小さかったり、複数あったりするケースもあるので、デフォルトにするのは難しいと判断したのではないかと想像されます。

その代わりにTurbo Framesがロード中の時は`turbo-frame`タグに[`busy`の属性がつけられます](https://turbo.hotwired.dev/reference/frames#html-attributes)。同様に[`aria-busy`もつきます](https://turbo.hotwired.dev/reference/attributes#automatically-added-attributes)。したがってCSSだけでローディングアニメーションがつけられます。

本サイトでは500msの遅延もつけているので少し複雑になっていますが、下記のCSSでTurbo Frameのローディングアニメーションを実装しています([GitHub](https://github.com/naofumi/hotwire_and_next/blob/a63ddd7828a40a6e2be5fe2fa4124767b4fe4474/public/hotwire/styles/input.css#L6))。

**/public/hotwire/styles/input.css**
```css
  .turbo-with-loader {
      position: relative;
  }

  .turbo-with-loader .turbo-hide-on-loading {
      position: relative;
      transition-delay: 500ms;
  }

  .turbo-with-loader .turbo-hide-on-loading::before {
      visibility: hidden !important;
      opacity: 0 !important;
      transition-delay: 500ms;
      transition-property: opacity;
  }

  .turbo-with-loader[busy] .turbo-hide-on-loading {
      visibility: hidden !important;
  }

  .turbo-with-loader[busy] .turbo-hide-on-loading::before {
      content: '';
      /* Visible will show at the beginning of the transition */
      visibility: visible !important;
      /* This will set opacity at the end of the transition */
      opacity: 1 !important;
      position: absolute !important;
      display: block;
      background-image: url('../../images/rocket.gif');
      width: 64px;
      height: 64px;
      top: 40px;
      left: 50%;
      transform: translateX(-50%);
  }
```

**/public/hotwire/styles/input.css**

```html
<!-- ローディングアニメーションを表示するTurbo Frame -->
<turbo-frame id="tabs" class="turbo-with-loader" data-turbo-action="replace">
     ...
     <!-- ローディングアニメーション表示中に隠すコンテンツ -->
     <div class="my-10 px-4 sm:px-6 lg:px-8 turbo-hide-on-loading" >
        ...
     </div>
     ...
</turbo-frame>
```

Turbo Framesを注意せずに使用すると、上記のNewsPicksのようなUXになってしまいがちです。CSSだけでローディングアニメーションが実装できますので、なるべくなら用意したほうが良いでしょう。ただしやり過ぎると画面がうるさくなってしまいますので、ケースバイケースで検討する必要があります。

場合によっては、ボタンやリンクだけにロード中の印をつけるのも良いでしょう。例えばTurboで`form`の送信をするときは、`data-turbo-submits-with`属性を使えば、[送信中にボタンの文言を変更できます](https://turbo.hotwired.dev/reference/attributes#data-attributes)。


<H2WithHash id="useeffect">ReactでuseEffectを使った場合</H2WithHash>

Reactで古典的なSPAを作成する場合は、useEffectを使ってデータを`fetch`します。この場合は[条件付きレンダー](https://ja.react.dev/learn/conditional-rendering)を使用してローディングアニメーションを表示します。

UXについては[Next.js useEffect画面遷移](/users)もしくは[タブメニューUI useEffect](/tabbed_segments)にデモを用意しています。

この場合は画面の対象部分は必ずすべてクリアされます。旧画面の上にローダーを重ねるのは難しく、旧画面は即時に全て消されます。ただしサーバのレスポンスが極端に遅くなければこれが問題になることはなく、むしろ初期レスポンスが速く感じられるでしょう。近年では汎用的なローディングアニメーションではなく、[スケルトンが使われることも多く](https://ws-design.net/skeleton_screen/)、これには適しています。

コードは一般に以下のようになります。

**pages/users/index.tsx**
```jsx
export default function UsersIndex() {
  ...
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    console.log("Fetch start for Users useEffect")
    fetch("/api/users").then(res => res.json())
      .then(data => {
        setUsers(data)
        setLoading(false)
      })
  },[])

  ...

  return (
    <Layout>
      {loading
        ? <div className="flex justify-evenly w-full mt-24 h-96 mb-48">
          <Image src={rocketImage} alt="loader" className="w-16 h-16"/>
        </div>
        : <>
          ...
         </>
       }
    </Layout>
  )
}
```

Next.jsの[Pages Router](/commentaries/loading_animations#loading-animations-with-ssr)のSSRに比べて、こっちのローディングアニメーションの方が考えやすく、かなり実装しやすくなっています。「SSRの方が却ってUXが悪い」という声を聞きますが、ここに原因があると思われます。


<H2WithHash id="react-server-components">Next.js App Router Server Componentsを使った場合</H2WithHash>

Next.jsの新しいApp Router Server Componentsの効果を確認します。

まずトップ画面最上部で遅延(delay)を2000msに設定し、Next.js Pages Router SSR画面遷移に移動してください。画面下部の「...へSSR(アニメーションを隠す)」ボタンをクリックすると、Next.js Pages Router SSRの画面遷移をご確認いただけます。

このようにReact Server ComponentsのSuspenseは、Server Componentsの利点を残しつつ、useEffectを使用した場合に近いUXを実現する効果があります。


export default function NewTabbedMenus({children}) {
  return <CommentaryLayout
    title="Loading Animations"
    subtitle="ローディングアニメーション"
    section="Commentary">
    <MDXRenderer>{children}</MDXRenderer>
  </CommentaryLayout>
}
