import MDXRenderer from "../../components/MDXRenderer";
import CommentaryLayout from "../../components/CommentaryLayout";
import StyledLink from "../../components/StyledLink";
import H2WithHash from "../../components/H2WithHash";
import Image from "next/image"
import amazonImage from "@/public/images/tabbed_amazon.png"
import turbodriveImage from "@/public/images/tabbed_turbodrive.png"
import turboframesImage from "@/public/images/tabbed_turboframes.png"

<H2WithHash id="create-tabbed-menus-with-turbo-frames">タブメニューはTurbo Framesで作ることが多い</H2WithHash>

他にも作り方はありますが、タブメニューは[Turbo Frames](https://turbo.hotwired.dev/handbook/frames)で作ることが多いです。Turbo Frames入門としては最適なUI要素です。

まずタブメニューの作る方に入る前に、Turbo Framesについて概略を説明します。

<H2WithHash id="turbo-ranking">Turboの序列</H2WithHash>

私の経験では、Turbo Drive, Turbo Frames, Turbo Streamsのうち、Turbo Driveはデフォルトで全てのページに適応されるので一番使うことが多いです。ついでTurbo Framesを多く使います。Turbo Framesは部分更新が必要な時に使います。最後のTurbo Streamsは人によって異なりますが、私の場合はほとんど使うことがありません。特にmorphingが導入されてからはTurbo Streamsが必要なケースが減ったように思います。

つまり私の場合は **Turbo Drive > Turbo Frames >> Turbo Streams** になります。Turbo Driveはすでに使い方を紹介しましたので（といってもほとんどインストールするだけでしたが）、あとはTurbo Framesを習得すればTurboのほとんどができるようになります。

<H2WithHash id="partial-rewrites-with-turbo-frames">Turbo Framesは部分的入れ替えのパッケージ</H2WithHash>

Turbo Driveがページ遷移、つまり画面全体の入れ替えをするのに対して、[Turbo Frames](https://turbo.hotwired.dev/handbook/drive)はサーバから送られてきたデータを使って画面の部分更新をする時に使います。

「モーダル」「ポップアップ」「ドロップダウンメニュー」「ドロワーメニュー（引き出し）」「ライブ検索」、住所を入力するときに使う「階層メニュー」などは、どれも[Turbo Frames](https://turbo.hotwired.dev/handbook/frames)で実装できます。インタラクティブと言われるUI要素も、大部分はシンプルな部分的入れ替えで実現できるためです。

Turbo Framesは部分更新だけではなく、これらのUI要素を作る時の周辺機能も提供してくれます。`a`タグや`form`タグとの[連携](https://turbo.hotwired.dev/handbook/frames)、[Lazy
loading (遅延ロード)](https://turbo.hotwired.dev/handbook/frames#lazy-loading-frames)、[prefetch](https://turbo.hotwired.dev/handbook/drive#prefetching-links-on-hover)、[URL同期](https://turbo.hotwired.dev/handbook/frames#promoting-a-frame-navigation-to-a-page-visit)、[ローダー表示用のCSS](https://turbo.hotwired.dev/reference/frames#html-attributes)など、それに伴う便利機能もパッケージとして提供しています。

一方でReactなどの場合は[`useState`フック](https://ja.react.dev/reference/react/useState)や[条件付きレンダー](https://ja.react.dev/learn/conditional-rendering)などのパターンを提供してくれますが、これを組み合わせてUI要素を作るのは開発者しだいです。その意味でReactはフルスクラッチでUI要素を作成するのに適している一方、HotwireはUIライブラリとまではいかないものの、パッケージしたものを提供していると言えます。


<H2WithHash id="tabs-MPA">古典的なMPAによるタブメニューの作り方</H2WithHash>

MPA流のタブメニューは[ここでお試しいただけます](/api/hotwire/tabbed_segments_no_js)。

早くTurbo Framesを使った実装を紹介したいところですが、その前にやっぱり **基本を振り返るおくことが重要だ** と思います。基本とは、古典的なMPAを使った場合のタブメニューの実装方法です。

実は古典的なMPAでも、ほぼ十分なUIが実現できます。[実際のデモ](/api/hotwire/tabbed_segments_no_js)を体験してください。

タブより上の箇所が全く同じ２つの画面を用意しているだけです。タブの上の方は全く同じなので、更新されていることに気づきません。一方でタブの下の部分は異なる内容が表示されているので、ここだけが更新されたとユーザは錯覚します。

例えば<StyledLink href="https://www.amazon.co.jp">Amazon.co.jp</StyledLink>のサイトでも、このようなMPA流のタブメニューが今でも現役です。ただ、残念ながらAmazonの場合はコンテンツシフトをしてしまっているので、ページ切り替えの時にタブの上やタブ内も動いてしまい、更新されていることに気づいてしまいます。コンテンツシフトさえしなければ、UXも十分に優れたものになります。


<div className="mt-4">
  <Image src={amazonImage} alt="amazon tabs"></Image>
</div>

<H2WithHash id="tabs-turbodrive">Turbo Driveによるタブメニューの作り方</H2WithHash>

Turbo Driveによるタブメニューは<StyledLink
href="http://localhost:3000/api/hotwire/tabbed_segments_turbodrive">ここでお試しいただけます。</StyledLink>

<StyledLink href="https://turbo.hotwired.dev/handbook/drive">Turbo Drive</StyledLink>を使う場合は、MPAのサイトに<StyledLink
href="https://turbo.hotwired.dev/handbook/installing">TurboのJavaScriptファイルをダウンロードする</StyledLink>だけです。
この場合はTurbo Driveによってヌルサクになった分だけ、タブの切り替えが自然に見えてきます。しかし実際にやっているのはMPAの場合と同様、<strong>画面全体の差し替えです。</strong>

一見するとタブだけが差し代わっているようには見えますが、下記の点を細かくみると、実際には画面全体の差し替えだとバレてしまいます。

* 少し下にスクロールした後にタブをクリックすると、タブの中身が差し代わるだけではなく、トップにスクロールしてしまうことがわかります。なおこの動きは画面全体を差し替えるから起こるのではなく、<StyledLink
    href="https://turbo.hotwired.dev/handbook/drive">Turbo Drive</StyledLink>がMPAの動きを真似るためにわざとやっているものです。条件と設定によってスクロールを抑制することも可能です。
* <code>Search</code>のテキスト入力フィールドに文字を入力し、その後にタブを切り替えると、テキスト入力フィールドの文字は消えてしまいます。これは画面全体を差し替える時にこのフィールドも丸ごと差し替えられるためです。
* なお、今回は<StyledLink href="https://turbo.hotwired.dev/handbook/drive">Turbo Drive</StyledLink>で画面全体が差し代わることを説明していますが、実は<StyledLink
    href="https://turbo.hotwired.dev/handbook/page_refreshes">Morphing</StyledLink>を使うと、全画面を書き換えつつ、差し替えるのではなく差分だけを更新することも可能です。Morphingについては後ほどまとめて紹介したいと思いますが、<StyledLink
    href="https://ja.react.dev/learn/preserving-and-resetting-state">Reactに近い更新</StyledLink>を可能にするもので、かなり強力なものです。

<div className="mt-6">
  <Image src={turbodriveImage} alt="turbodrive image"></Image>
</div>


<H2WithHash id="tabs-turboframe">Turbo Framesによるタブメニューの作り方</H2WithHash>

Turbo Framesによるタブメニューは<StyledLink
href="http://localhost:3000/api/hotwire/tabbed_segments_turboframes">ここでお試しいただけます。</StyledLink>

まず大切なことは、<StyledLink href="https://turbo.hotwired.dev/handbook/turboframes">Turbo
Frames</StyledLink>を使った場合のUIの違いです。一見するとTurbo Driveの場合とあまり差がありませんが、以下の点が異なります。

* 少し下にスクロールした後にタブをクリックしても、トップにスクロールしません。デフォルトではスクロール位置が維持されます。より細かく制御したい場合は、<code>autoscroll</code>属性で<StyledLink
    href="https://turbo.hotwired.dev/reference/frames#html-attributes">調整できます</StyledLink>。
* Searchのテキスト入力フィールドに文字を入力し、その後にタブを切り替えても、テキスト入力フィールドの文字はそのまま維持されます。フォーカルも維持されます。今回設定したTurbo
    Framesでは、Searchのテキスト入力フィールドはTurbo
    Framesの外にあります（下図）。タブが切り替わっても、SearchのDOM要素はそのままなのです。だから文字およびフォーカスが維持されています。

このようにTurbo Framesの特徴は画面を枠で分割し、枠内を差し替えつつ、枠外をそのままに維持するところです。

Turbo Framesによるタブメニューの作り方はごく簡単です。まずは<StyledLink
href="/commentaries/tabbed_menus#tabs-turbodrive">Turbo Driveのバージョン</StyledLink>から出発します。そして、どこをTurbo
Framesで囲むかを決めます。今回はSearchのテキスト入力フィールドの下のところからテーブルの最後までを囲むことにします。

<div className="mt-4">
  <Image src={turboframesImage} alt="turbo frames image"></Image>
</div>

次にエディタで該当するEJSファイルの内容を確認し、囲みたいところを <code>&lt;turbo-frame
id=&quot;[適当な名前]&quot;&gt;&lt;/turbo-frame&gt;</code>のタグで囲みます。今回は２つのページ
(<code>Users</code>と<code>Products</code>)がありますので、双方のEJSファイルで同じ処理をします。結果は<StyledLink
href="https://github.com/naofumi/hotwire_and_next/blob/main/templates/tabbed_segments_turbodrive/index.ejs">templates/tabbed_segments_turboframes/index.ejs</StyledLink>および<StyledLink
href="https://github.com/naofumi/hotwire_and_next/blob/main/templates/tabbed_segments_turbodrive/index.ejs">templates/tabbed_segments_turboframes/products.ejs</StyledLink>にあります。

はい、以上でおしまいです！

少し解説を加えます。

&lt;turbo-frame&gt;&lt;/turbo-frame&gt;でくくることによって、Turbo
Frame中に含まれる<code>a</code>タグや<code>formタグは</code>タグは通常と違う性質を持つようになります。通常であれば<StyledLink
href="https://turbo.hotwired.dev/handbook/drive">Turbo Drive</StyledLink>のような全画面遷移をするのではなく、デフォルトでは同じTurbo
Frame内の画面遷移をするように変化します。

今回はTurbo Frameの中にタブがくるように配置しましたので、<code>Users</code>, <code>Products</code>のタブはTurbo Frame内の遷移をするように切り替わっています。

タブを押すと、通常の<code>a</code>タグと同じようにHTTPリクエストは飛びます。そして全画面分のHTMLが返ってくるのきます。しかしそれで画面全体を入れ替えるのではなく、新しいページにある&lt;turbo-frame&gt;&lt;/turbo-frame&gt;を探し出し、その中身を入れ替えるのです。この時、<code>id</code>属性をみて<code>turbo-frame</code>のペアを認識するので、<code>id</code>を揃えておく必要があります。

これだけでTurbo Framesによるタブメニューが出来上がりました。

<H2WithHash id="tabs-comparison-with-react">Reactとの比較</H2WithHash>

Reactによるタブメニューは<StyledLink
href="http://localhost:3000/tabbed_segments">ここでお試しいただけます。</StyledLink>

<StyledLink href="https://github.com/naofumi/hotwire_and_next/blob/main/pages/tabbed_segments/index.tsx">Reactの場合</StyledLink>は、どのタブが選択されているかを


<H2WithHash id="tabs-summary">タブメニューのまとめ</H2WithHash>

今回はTurbo Framesによるタブメニューを実装しました。非常に簡単なものでしたので、UI的にMPAと大きな差はありませんでした。しかしTurbo
Framesの枠外のステートが維持できていることが確認できました。

今後はもう少しだけ設定やJavaScriptを加えながら、より多くのUIをTurbo Framesで実装していこうと思います。



export default function NewTabbedMenus({children}) {
  return <CommentaryLayout
    title="Tabbed Menus"
    subtitle="タブメニュー"
    section="Commentary">
    <MDXRenderer>{children}</MDXRenderer>
  </CommentaryLayout>
}
