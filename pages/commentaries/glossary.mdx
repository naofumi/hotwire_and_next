import CommentaryLayout from "../../components/CommentaryLayout";
import MDXRenderer from "../../components/MDXRenderer";
import Image from "next/image"
import csrSsrSpaMpaImage from "@/public/images/csr-ssr-spa-mpa.webp"

## CSR, SSR, SPA, MPA ===csr-ssr-spa-mpa===

主にNext.jsによって一般的になった用語かと思いますが、人によって使い方がまちまちで、コミュニケーションに苦労します。

本サイトでは下記のように定義して使用しています。この定義が最も[MECE(漏れなく・ダブりなく)](https://ja.wikipedia.org/wiki/MECE)になりますので、各技術の違いを論じるのに適していると私は考えています。

<div className="mt-8 flow-root">
  <div className="-mx-4 -my-2 overflow-x-auto sm:-mx-6 lg:-mx-8">
    <div className="inline-block min-w-full py-2 align-middle sm:px-6 lg:px-8">
      <table className="min-w-full divide-y divide-gray-300">
        <caption className="caption-top text-left font-bold">CSR, SSR, MPA, SPAの定義</caption>
        <thead>
        <tr>
          <th scope="col" className="py-3.5 pl-4 pr-3 text-left text-sm font-semibold text-gray-900 sm:pl-3">視点</th>
          <th scope="col" className="py-3.5 pl-4 pr-3 text-left text-sm font-semibold text-gray-900 sm:pl-3">技術</th>
          <th scope="col" className="py-3.5 pl-4 pr-3 text-left text-sm font-semibold text-gray-900 sm:pl-3">名前</th>
          <th scope="col" className="min-w-28 px-3 py-3.5 text-left text-sm font-semibold text-gray-900">どこでRenderingされるか？</th>
          <th scope="col" className="min-w-28 px-3 py-3.5 text-left text-sm font-semibold text-gray-900">ページ間でメモリは維持されるか？</th>
        </tr>
        </thead>
        <tbody className="bg-white whitespace-nowrap">
        <tr className="even:bg-gray-50">
          <td rowSpan={2} className="px-3 py-4 text-sm text-gray-500">**レンダリング**</td>
          <td className="px-3 py-4 text-sm text-gray-500">**CSR**</td>
          <td className="px-3 py-4 text-sm text-gray-500">Client-Side Rendering</td>
          <td className="px-3 py-4 text-sm text-gray-500">ブラウザ</td>
          <td className="px-3 py-4 text-sm text-gray-500">どちらでも良い</td>
        </tr>
        <tr className="even:bg-gray-50">
          <td className="px-3 py-4 text-sm text-gray-500">**SSR**</td>
          <td className="px-3 py-4 text-sm text-gray-500">Server-Side Rendering</td>
          <td className="px-3 py-4 text-sm text-gray-500">サーバ</td>
          <td className="px-3 py-4 text-sm text-gray-500">どちらでも良い</td>
        </tr>
        <tr className="even:bg-gray-50">
          <td rowSpan={2} className="px-3 py-4 text-sm text-gray-500">**メモリ維持**</td>
          <td className="px-3 py-4 text-sm text-gray-500">**SPA**</td>
          <td className="px-3 py-4 text-sm text-gray-500">Single-Page Application</td>
          <td className="px-3 py-4 text-sm text-gray-500">どちらでも良い</td>
          <td className="px-3 py-4 text-sm text-gray-500">維持される</td>
        </tr>
        <tr className="even:bg-gray-50">
          <td className="px-3 py-4 text-sm text-gray-500">**MPA**</td>
          <td className="px-3 py-4 text-sm text-gray-500">Multi-Page Application</td>
          <td className="px-3 py-4 text-sm text-gray-500">どちらでも良い</td>
          <td className="px-3 py-4 text-sm text-gray-500">維持されない</td>
        </tr>
        </tbody>
      </table>
    </div>
  </div>
</div>

### CSR: Client-Side-Rendering ===CSR===

* ブラウザの中でJavaScriptコードが実行されて、その結果としてHTMLを生成（レンダリング）するやり方

### SSR: Server-Side-Rendering ===SSR===

* サーバでHTMLが生成（レンダリング）され、ブラウザにHTMLが送信されるやり方

### SPA: Single-Page Application ===SPA===

* 全画面を書き換える画面遷移は行わないウェブページ。つまり画面の部分的な置換でUI/UXを構成したもの
* Hotwire TurboDrive, React Router, Next.jsのLinkタグを使った画面遷移では`<head>`タグは保持し、`<body>`タグの内容だけを更新します。そのため、SPAと分類

### MPA: Multi-Page Application ===MPA===

* 全画面を書き換える画面遷移を行い、その際は`<head>`タグの中身を含めたページ全体をブラウザメモリから消し、まっさらな状態から次のページを描画するもの
* ブラウザのネイティブな画面遷移はMPAに相当

### 判断に迷いやすいケースの解釈 ===confusing-cases===

この分類をすると、例えば以下のケースもCSR, SSR, SPA, MPAの用語で解説できます。

* SSG (Static-Site Generation)はSSRの１例として解釈されます。サーバからブラウザに送られるのはHTMLファイルであるため、サーバでレンダリングされたと考えるためです。またNext.jsのISR (Incremental Static Generation)も同様にSSRの１例として考えます
* Ruby on Rails, PHP, DjangoなどのHTMLテンプレートを使ったウェブページもSSRの１例として解釈されます。HTMLがサーバでレンダリングされるためです。Hydrationの有無はSSRの必要条件とは考えません
* Next.jsで`getServerSideProps()`を使ったページは、状況によってCSRであり、SSRであり、SPAであり、MPAでもあります
    * 初回ロード時はサーバでHTMLがレンダリングされ、ブラウザはこれをそのまま表示します。つまりSSRです
    * `Link`タグを使って画面遷移するときは、サーバからJSONが送られてきます。このJSONを使って、JavaScriptがHTMLをレンダリングして、リンク先のページを画面に表示します。つまりCSRです
    * `Link`タグを使って画面遷移をするときは`<head>`タグを残して、`<body>`タグの中だけが(主に)変化します。つまりSPAです
    * `Link`タグではなく、ただの`a`タグを使って画面遷移をすれば`<head>`タグを含めて、ページ全体がメモリから消去され、次のページはゼロから描画されます。つまりMPAです
* React Server ComponentsはRSC payloadをサーバからブラウザに送ります。これはHTMLにかなり近いもので、HTMLの構造がそのまま記載されています。したがってSSRの１例と捉えます

### 組み合わせ ===combinations===

* **SSR + MPA:** Amazonや楽天はブラウザのネイティブな画面遷移をしておりSSR + MPAです
* **SSR + SPA:** Turbo Driveで作ったページはすべてSSRですが、２ページ目以降の画面遷移はSPAになります。サーバからはHTMLが送られてきて、そこから`<body>`のところを切り取って、置換しているためです
* **CSR + SPA:** Create-React-Appで作ったReactのウェブアプリがこれになります。描画されるHTMLはすべてブラウザ名の中でJavaScriptがレンダリングします。React RouterでURLを変更する機能を入れても、変わりません
* **CSR + MPA:** [Apple Store](https://www.apple.com/jp/shop/buy-iphone/iphone-15)はReactを使ってJavaScriptがHTMLをレンダリングしています。製品のオプションを選択しているときはページが遷移せず、インタラクティブに次のオプションが現れたり、価格が変更されたりします。ここはCSRです。一方で異なるページへのリンクはすべてページのリロードを伴います。よってMPAです。


<figure className="mt-12">
  <figcaption className="font-bold">CSR, SSR, SPA, MPA</figcaption>
  <Image src={csrSsrSpaMpaImage} alt="CSR, SSR, SPA, MPA description" />
</figure>

## レンダリング ===rendering===

[「レンダリング」は一般には画像、映像、音声が出力される処理を指す](https://e-words.jp/w/レンダリング.html)が、特にReact SPAの場合はこの意味で使われていません。Reactの場合はデータが画面に表示されるまでの工程が複雑ですので、先にこれを解説します。

1. 画面に表示されるべきデータがJSON等の形式で取得される
2. JSONのデータがコンポーネント関数により、`ReactNode`のツリーに変換される
3. `ReactNode`のツリーとブラウザのDOM (画面に表示されているもの)が[比較され](https://legacy.reactjs.org/docs/reconciliation.html)、差分がブラウザDOMに書き込まれる
4. DOMがブラウザに表示される

一般的な用法により近いのは4.のステージだと思いますが、Reactの世界では主に2.のステージを指しているように思います。そこで**本サイトでも2.の意味で使用します**。ただし`ReactNode`だけでなく、HTMLとしての出力もレンダリングと考えますし、React Server ComponentsのRSC Payloadの出力もレンダリングと考えています。広義にはブラウザDOMに反映する直前の状態がレンダリングだと考えています。

## 非同期通信 ===asynchronous-communication===

ウェブの「非同期通信」もまた明確な定義がない言葉です。ウェブを検索すると色々なものが出てきます。

1. サーバと通信中にユーザが別の操作ができること
2. 画面の遷移がないこと

しかしReact Routerを使ったSPAでは、`XMLHttpRequest`や`fetch`を使って画面全体を遷移させますし、また画面いっぱいにローダーをすぐに出しますので、ユーザは別の操作ができません。`XMLHttpRequest`や`fetch`の使い方が多様になっていますので、UI/UX視点で定義するのは不可能に思われます。

本サイトでは「非同期通信」は旧ページのJavaScriptやCSSをメモリからすべて消すかどうか、それとも新ページを表示するときもメモリ上の同じJavaScriptやCSSを引き継ぐかどうかだけを基準にして考えています。つまりSPAとMPAの区別と同じように考えています。

## Hydration ===hydration===

ReactでSSRを行い、サーバからブラウザにHTMLを送信した場合、このままではページはインタラクティブになりません。つまりクリックなどに反応しません。インタラクティブにするにはHydrationが必要です。

### なぜReact SSRはインタラクティブにならないのか？

ボタンをクリックに応答させるには、ボタンのHTMLにイベントハンドラを接続する必要があります。イベントハンドラとはクリックしたイベントを受け取り、実行されるJavaScriptのことです。

イベントハンドラを接続するために、JavaScriptをダウンロードし、CSRと同じように完全なウェブページをブラウザの中で作り上げます。ただし画面には表示せずに、裏でやります。裏で作られたウェブページにはイベントハンドラがありますので、画面に表示されているボタン等にこのイベントハンドラを繋げます。

### ネイティブなMPAやHotwire Turbo DriveではHydrationが不要なのか？

ネイティブなMPAやHotwire Turbo DriveではHydrationは不要です。HydrationをせずにイベントハンドラをHTMLに接続できます。

JavaScriptはもともとHTMLと分割管理されるようにできており、HTMLに簡単にイベントハンドラがつけられます。ネイティブなMPAやHotwire Turbo Driveではこの仕組みを使っているため、裏でウェブページを再構成するような処理は不要です。


## SEO ===seo===

SEO (Search Engine Optimization:検索エンジン最適化)はGoogle等の検索サイトの上位に表示させる一連の対策を指します。また検索結果が表示された時に表示される`meta description`タグ、あるいはSNSで共有された時に表示されるOGPタグなどもSEO対策の一環として考えることが多いです。

SEO用のタグはHTMLの`<head>`タグの中に書くものです。一方SPAは通常`<body>`タグの中だけを変更させますので、SEOタグに対応するのには別途対策が必要でした(例えば[react-helmet](https://www.npmjs.com/package/react-helmet))。しかしNext.jsもTurboもそのままで`<head>`タグ内部を書き換える仕組みを備えているので、ライブラリを用意しなくても十分に対応できます。

一方で検索サイト上位に表示させるときは注意が必要です。**CSR/SPAでは検索サイト上位に表示されにくくなる可能性があります**。

各検索サイトは"crawler"もしくは"spider"というボットを使って、自動的にインターネットのウェブサイトにアクセスし、その情報を蓄積します。ユーザが検索サイトを利用する場合は、ここで集めた情報に対して検索が行われます。しかし歴史的にはこのボットはJavaScriptを実行できませんでした。CSRを使った場合はHTMLをレンダリングするためにJavaScriptが必要なので、ボットはCSRサイトの情報を収集できませんでした。つまりCSRを使ったサイトは検索サイトの上位に表示されなかったのです。

GoogleのボットはJavaScriptを実行でき、情報収集が正しくできると考えられています。しかしそれでも**JavaScriptを必須とするサイトの方が情報収集に時間を要するという話もあり、不利である可能性があります**。残念ながらGoogleを筆頭に各検索サイトはアルゴリズムを非公開にしていますので、この辺りは正確な情報が得られません。またJavaScriptを実行するには多くの処理能力を必要とするので、**Google以外の検索サイトについては依然としてCSRのサイトを検索できない**と言われています。

**確実なSEO対策をするのであれば、やはりサーバ側でHTMLレンダリングが行われるSSRの方が安心でしょう。**

export default function ({children}) {
  return <CommentaryLayout
    title="Glossary"
    subtitle="言葉の定義"
    section="Appendix">
    <MDXRenderer>{children}</MDXRenderer>
  </CommentaryLayout>
}
