import MDXRenderer from "../../components/MDXRenderer";
import CommentaryLayout from "../../components/CommentaryLayout";
import H2WithHash from "../../components/H2WithHash";
import Image from "next/image";

モーダルダイアログはUI要素としてウェブデザインで非常によく使われます。よって**簡単にモーダルダイアログが作れることが開発者としては重要**です。

またモーダルに表示する内容は、**サーバから動的に取得する**こともよくあります。この場合はモーダルの表示・非表示だけでなく、サーバにリクエストを投げてレスポンスを表示することも必要になります。これをすべて、裏の画面のステート(スクロール位置など)を維持しながら行う必要があります。**ネットワーク由来の遅延対策も必要であり、ちゃんとやろうとすると意外と大変です**。

下記ではUXおよび実装の簡単さを重視しつつ、モーダルダイアログの作り方を複数検討します。Hotwireに加え、**Next.jsのApp RouterとPages Routerについてもモーダルの出し方を検討し**、比較します。

1. [Turbo Frames: カスタムJavaScriptなしでモーダルを出す方法](#turbo-without-custom-javascript)
2. Turbo Frames: カスタムJavaScriptを追加してモーダルのUI/UXを改善する方法
    1. [JavaScriptをインラインで書いた場合](#turbo-with-custom-javascript)
    2. [CSSでローディングアニメーションを追加した場合](#turbo-css-loader)
    3. [Stimulusでイベント処理を改善した場合](#turbo-with-stimulus)
3. [React: useEffectでモーダルを出す方法](/commentaries/modal_dialogs#react-useeffect)
4. [React: Client Componentsでモーダルを出す方法](/commentaries/modal_dialogs#react-client-components)
5. [React: Server Componentsでモーダルを出す方法](/commentaries/modal_dialogs#react-server-components)
5. [React: Server ComponentsとLayoutでモーダルを出す方法](/commentaries/modal_dialogs#react-server-components-with-layouts)

<H2WithHash id="turbo-without-custom-javascript">Turbo Frames: カスタムJavaScriptなし</H2WithHash>

まずはHotwire/Turbo Framesを使って、カスタムのJavaScriptを書かずにモーダルを出す方法を紹介します。

サーバから動的な内容をモーダルを表示する際は、通常は２つステップが必要です。

1. モーダルを表示する (カスタムJavaScriptで行う: HotwireならStimulus)
2. モーダルのコンテンツをサーバにリクエストし、結果をモーダル内に表示する (AJAX/fetchで行う: HotwireならTurbo Frames)

しかし、サーバからの**レスポンスと一緒にモーダルの「枠」も同時に送り返せば、モーダルを開くJavaScriptが必要なステップ1.は省略可能**になります。これがこの方法の特徴です。

### コード

必要なコードは以下のものになります。ただしコントローラアクションは一般的なものなので、省略します(`pages/api/hotwire/modal_no_js`)。

#### 1. モーダルの「枠」とコンテンツのHTMLページ: `templates/modal_no_js/modal.ejs`

```html
<turbo-frame id="modal">
   ...[モーダルのコンテンツおよびモーダルの枠]...
</turbo-frame>
```
* これはモーダルの中に表示する内容 + モーダルの「枠」です
* ブラウザからのTurbo Framesのリクエストを受けて、サーバからブラウザに送信されます

#### 2. モーダル表示のトリガー: `templates/modal_no_js/index.ejs`

```html
<a href="/api/hotwire/modal_no_js/modal?id=<%= user.id %>"
   data-turbo-frame="modal"
   class="text-orange-600 underline inline-block active:scale-105"><%= user.name %></a>
```

* `a`タグをクリックすると、`/api/hotwire/modal_no_js/modal?id=1`からモーダルの中身(HTML)がダウンロードされます
* ダウンロードされたHTMLを`turbo-frame "modal"`に挿入します（既存の中身と差し替えます）

#### 3. モーダルHTML断片の差し込み先: `templates/modal_no_js/index.ejs`

```html
<turbo-frame id="modal"></turbo-frame>
```

* ここが`turbo-frame "modal"`であるという指示です
* サーバからダウンロードされたHTMLをここに挿入しなさいという指示になります

#### 4. モーダルを閉じるボタン: `templates/modal_no_js/modal.ejs`

```html
<a class="p-1 text-sm w-auto hover:cursor-pointer translate-x-2 active:scale-125"
     href="/api/hotwire/modal_no_js">
```
* 今回はカスタムJavaScriptを避けますので、`onclick`等が使えません
* JavaScriptを使わない場合、ブラウザのインタラクションは`a`タグや`form`タグにほぼ限定されます。
* そこで`a`タグを使用して、モーダル表示前のページをリクエストしています。

ブラウザが受け取るHTMLレスポンスには空の`turbo-frame`が含まれています。Turbo Framesは既存の`turbo-frame`をこの空の`turbo-frame`に入れ替えます。その結果、`turbo-frame`の中身は空になり、枠も無くなるのでモーダルが閉じます。ブラウザが受け取るHTMLは`turbo-frame`だけではなく、`templates/modal_no_js/index.ejs`のすべてですが、画面に反映される（差し込まれる）のは`turbo-frames`の中身(空)だけであることに注意してください。

### UI/UX

[カスタムJavaScriptなしで作ったデモ](/api/hotwire/modal_no_js)を用意していますので、ご覧ください。[トップページ](/)からで遅延を設定できますので、300msの場合と2000msの場合を比較してください。

* サーバのレスポンスが十分に速い場合(300msの場合)は快適です。
* しかし遅延を2000msに設定するとUI/UXの弱点が見えてきます。リンクを押してもフィードバックがなく、ユーザはシステムが正しく動作している自信が持てません。またモーダルを閉じる時も遅延が発生します。「閉じるだけなら瞬間的に行くのでは？」というユーザ期待と反して、サーバからレスポンスが帰ってくるまでモーダルは閉じません。<br />(リンク等をクリックした時にCSS `:active`を使っていますが、十分なフィードバックとは言えません)

カスタムJavaScriptなしの場合はコードが非常に簡素で、直感的にもわかりやすいものになります。しかし、特にネットワークが遅い場合は、ユーザの操作に対するフィードバックが弱く、良いUI/UXとは言えません。



<H2WithHash id="turbo-with-custom-javascript">Turbo Frames: Inline JavaScript</H2WithHash>

上記の[Turbo Frames: カスタムJavaScriptなし](http://localhost:3000/commentaries/modal_dialogs#turbo-without-custom-javascript)の問題点を解消し、ネットワークが遅い場合でも十分なUI/UXを提供するためにカスタムJavaScriptを書きます。上記ではモーダルの「枠」をサーバから送ることでモーダルを開くステップを省略していました。しかしここでは**ちゃんとJavaScriptを使って、サーバレスポンスの遅延の有無に関わらず、リクエストを投げた瞬間にモーダルを開きます**。これがユーザに対するフィードバックとなり、UI/UXの改善に繋がります。

なおHotwireでカスタムJavaScriptを書く場合は、一般には[Stimulus](https://stimulus.hotwired.dev)を使います。これは非常に便利ですが、**最初はとっつきにくいので、インラインJavaScriptを使った例から紹介します**。

### コード

JavaScriptなしの場合と比較して、以下のコードが追加されます。

1. モーダルの「枠」のHTMLをあらかじめ元のページに挿入しておきます。ただし`display:none`で隠して見えなくします。この中にHTML断片を差し込む目印の`turbo-frame`を入れておきます
2. モーダルの表示をトリガーするJavaScriptの設置。Turboがサーバにリクエストを投げるのは前回と変わらないのですが、これとは独立にモーダルを表示するJavaScriptを用意します。リンクをクリックしたときに、この２つが同時に実行されます。
3. モーダルを閉じるボタンがJavaScriptを呼び、モーダルだけが閉じるようにします。

**1. モーダルの「枠」と内容を含むHTMLページ: `templates/modal_w_js/modal.ejs`**

```html
<turbo-frame id="modal">
   ...[モーダルのコンテンツ]...
</turbo-frame>
```

JavaScriptなしの場合と比べると、モーダルの「枠」をここに書いていないのが特徴です。モーダルの中身だけを置いておきます。


**2. モーダル表示のJavaScript: `templates/modal_w_js/index.ejs`**

```html
<script>
  function openModal() {
    const turboFrame = document.querySelector("turbo-frame#modal")
    turboFrame.innerHTML = '<div>Loading... </div>'
    const modal = document.querySelector(".modal-dialog")
    modal.classList.add("modal-open")
  }

  function closeModal() {
    const modal = document.querySelector(".modal-dialog")
    modal.classList.remove("modal-open")
  }
</script>
```

モーダルの表示・非表示を制御するJavaScriptを、`script`タグで囲んでインラインで書いています。内容は単にモーダルの「枠」に`.modal-open`のCSSクラスをつけたり外したりするだけです。さらに`openModal()`では、`turbo-frame`の"Loading..."と表示させ、ローディング中の表示をさせています。


**3. モーダル表示のトリガー: `templates/modal_w_js/index.ejs`**

```html
<a href="/api/hotwire/modal_w_js/modal?id=<%= user.id %>"
   data-turbo-frame="modal"
   onclick="openModal()"
   class="text-orange-600 underline inline-block active:scale-105">
  <%= user.name %>
</a>(Inline JS)<br>
```

"Inline JS"と書いてある方の`a`タグに着目します。まず`onclick`属性で`openModal()`を呼び出して、モーダルを表示させています。さらに`data-turbo-frame="modal"`属性がありますので、`href`で指定したエンドポイントから得られたHTMLを`turbo-frame id="modal"`に差し込むという指示になります(上記と同じ)。

`a`タグにこの２つの属性をつけることにより、モーダルを表示させるコードとTurbo Frameにデータを読み込むコードを分けることができました。そのため、サーバからのレスポンスが遅延しても、まず先にモーダルを表示させることができました。

「モーダルの開閉」「サーバからのデータの読み込み」を独立させたことがポイントと言えます。

**4. モーダルを閉じるボタン: `templates/modal_w_js/modal.ejs`**

```html
<button class="p-1 text-sm w-auto hover:cursor-pointer translate-x-2 active:scale-125"
        onclick="closeModal()">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"
       class="mx-auto size-6 text-orange-600">
    ...
  </svg>(Inline JS)
</button>
```

モーダルを閉じる`button`タグでは、`onclick="closeModal()"`としています。先ほど用意した`closeModal()`を呼び出して、モーダルを閉じています。[カスタムJavaScriptを使わない例](/commentaries/modal_dialogs#turbo-without-custom-javascript)と異なり、モーダルの開閉とサーバからのデータの読み込みが分かれていますので、モーダルだけ瞬時に閉じることができています。

### UI/UX

[JavaScriptを使った例のデモを用意しています](/api/hotwire/modal_w_js)ので、お試しください。他の例も同じデモ画面に含めていますので、"Inline Javascript"のUI/UXを確認する場合は、"Inline JS"と書いてあるボタンを押してください。

* モーダルダイアログは瞬時に表示されます
* サーバのレスポンスが遅い場合は"Loading..."と表示されますので、リクエストが送信され、サーバのレスポンス待ちであることがわかります。ユーザへのフィードバックが適切にされていますので、UI/UXは良くなっています。
* クローズボタンを押したときにモーダルダイアログは瞬時に閉じます。これはユーザの期待に沿いますので、UI/UXは良くなっています。

### まとめ

* カスタムJavaScriptなしの例に比べて多少はコードが増えていますが、10行程度です
* モーダル「枠」はサーバから送信されるのではなく、元のページに含まれています

Turbo Framesを使うと[カスタムJavaScriptなし](commentaries/modal_dialogs#turbo-without-custom-javascript)でもモーダルが作れます。宣伝文句としてはインパクトがあるせいか、このやり方を非常に多く見かけるように思います。しかしHotwireがStimulusとセットになっていることからも分かるように、**HotwireはむしろカスタムJavaScriptを書くことを奨励しています**。そしてここで確認したように、わずか10行程度のJavaScriptでUI/UXを大きく改善できています。

ぜひ「JavaScriptなし」の宣伝文句に踊らされず、UI/UXを改善する簡単なJavaScriptを使うようにしていただければと思います。



<H2WithHash id="turbo-css-loader">Turbo Frames: CSSローディングアニメーション</H2WithHash>

[Inline JavaScript](#turbo-with-custom-javascript)の項では、カスタムJavaScriptを使ったおかげでモーダルが瞬時に表示されるようになりました。つまりサーバからのレスポンスよりも前にモーダルが表示されます。そのため、なんらかのローディングアニメーションが必要になります。

前の項では単純に"Loading..."の文字列をJavaScriptで差し込みました。これでも良いのですが、Turboはロード中に`busy`のHTML属性を自動的に付けてくれますので、CSSだけでもローディングアニメーションを表示できます。ここではこの方法を紹介します。

### コード

デモで使用しているコードはもう少し複雑ですが、ポイントを下に記しました。

**hotwire/styles/input.css**
```css
.turbo-with-loader .turbo-hide-on-loading {
    /*　GIFイメージは`position: absolute`で配置するので、
        ここを`position: relative` にする*/
    position: relative;
}

.turbo-with-loader .turbo-hide-on-loading::before {
    visibility: hidden !important;
    opacity: 0 !important;
}

.turbo-with-loader[busy] .turbo-hide-on-loading {
    visibility: hidden !important;
}

.turbo-with-loader[busy] .turbo-hide-on-loading::before {
    content: '';
    visibility: visible !important;
    opacity: 1 !important;
    position: absolute !important;
    display: block;
    background-image: url('../../images/rocket.gif');
    width: 64px;
    height: 64px;
    top: 40px;
    left: 50%;
    transform: translateX(-50%);
}
```

* `turbo-frame`には`turbo-with-loader`CSSクラスを付けています。
* アニメーション表示のときに隠したい部分を`turbo-hide-on-loading`で囲っています。ここの`::before`擬似要素にローディングのGIFアニメーションを表示します
* アニメーションの表示・非表示は`turbo-with-loader`CSSクラスがついている`turbo-frame`の`busy`属性で切り替えます。`busy`なら隠したい部分(`turbo-hide-on-loading`を持つ)が非表示になり、かつ`::before`のところのGIFアニメーションが表示されます
* 結論として、`turbo-with-loader`と`turbo-hide-on-loading`を適切にHTMLに付けてあげるだけでローディングアニメーションが動きます

### UI/UX

[デモ画面](/api/hotwire/modal_w_js)の"CSS loader"と付いているボタンを押してください。このボタンを使うと、`turbo-hide-on-loading`がついたHTML要素が使われ、適切にアニメーションが動きます。特にサーバレスポンスを遅延させてお試しください。

* モーダルが表示されると中にアニメーションが表示され、システムが正しく動作している安心感をユーザに与えます。良いUI/UXです

### まとめ

* Turbo Framesは動作中に`turbo-frame`要素に[`busy`属性を付けてくれます](https://turbo.hotwired.dev/reference/frames#html-attributes)([`busy-aria`属性も付けてくれます](https://turbo.hotwired.dev/reference/attributes#automatically-added-attributes))
* これを使うと、ローディングアニメーションをCSSだけで実装できます



<H2WithHash id="turbo-with-stimulus">Stimulusでイベント処理を改善</H2WithHash>

上記のように、Turbo FramesとカスタムJavaScriptおよびCSSを使うと、かなりUI/UXの良いモーダルダイアログが作成できます。サーバからリクエストを受け取ってデータを表示しているにも関わらず、必要なコードは少なく、処理の流れも直感的でわかりやすくなっています。

しかしHTMLの`onclick`属性を使用しているところが問題です。`onclick`属性等の[インラインのイベントハンドラーはとても使いやすいのですが、一般には使用するべきではないとされています](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#inline_event_handlers_—_dont_use_these)。主な理由は、`onclick`等の属性の中に記述できるのはグローバル関数であり、コードがこんがらがってしまうことにあるようです。(その心配がない程度の小さいところなら、実は私も良く使ったりしていますが...)

一般に推奨されているのは[`addEventListener()`](https://developer.mozilla.org/en-US/docs/Web/Events/Event_handlers#eventtarget.addeventlistener)を使うことです。ただしHTMLとJavaScriptが分かれているおかげで責務の分離ができているのは良いのですが、関連が分かりにくくなるという欠点もあります。

もう１つ`addEventListener()`を使った場合の欠点があります。AJAX/fetchによる部分置換が多いインタラクティブなページの場合、イベントを付けたり外したりするのが大変になります。例えばfetchにより新たなHTML要素が表示された場合、その都度`addEventListner()`でイベントをつけなければなりませんが、その処理が大変です。

Stimulusはこの問題を解決してくれるライブラリで、下記の特徴があります。

* AJAX/fetchをするページでのイベントハンドラー処理を完全自動化
* HTMLとJavaScriptの関連が分かりやすくなる
* JavaScriptコードの再利用性が高まる

今回は各ポイントに軽く触れながら、Stimulusで書いたコードを紹介します。[CSSローディングアニメーションをつけたデモ](#turbo-css-loader)をベースに話します。

**1. モーダル表示のJavaScript: `public/hotwire/javascript/labeler_controller.js`**

```js
import {Controller} from "/hotwire/javascript/stimulus.js"

export default class extends Controller {
  static values = {"selector": String}
  static classes = ["label"]

  add() {
    const labelable = document.querySelector(this.selectorValue)
    labelable.classList.add(this.labelClass)
  }

  remove() {
    const labelable = document.querySelector(this.selectorValue)
    labelable.classList.remove(this.labelClass)
  }
}
```

ここがStimulus Controllerです。行う処理は選択されたHTML要素(`labelable`)にCSSクラス(`this.labelClass`)を付けるだけの非常にシンプルなものです。
名前は`labeler_controller.js`としています。[Inline JavaScriptの例](#turbo-with-custom-javascript)の数行のJavaScriptを代替しているだけですので、それもそのはずです。`add()`でCSSクラスをつけて、`remove()`で外しているだけです。

これではよくわからないかと思いますが、次のトリガーを一緒に見ながらStimulusの特徴を紹介します。

**2. モーダル表示のトリガー: `templates/modal_w_js/index.ejs`**

```html
<div class="inline-block min-w-full py-2 align-middle sm:px-6 lg:px-8"
     data-controller="labeler"
     data-labeler-selector-value=".modal-dialog"
     data-labeler-label-class="modal-open"
>
  ...
  <a href="/api/hotwire/modal_w_js/modal?id=<%= user.id %>"
     data-turbo-frame="modal"
     data-action="click->labeler#add "
     class="text-orange-600 underline inline-block active:scale-105">
    <%= user.name %>
  </a>(Stimulus)
  ...
</div>
```

ここがモーダル表示のトリガーです。

1. `data-controller="labeler"`は、この`div`タグに囲まれている部分を`javascript/labeler_controller.js`に繋げるためのものです。
2. `data-labeler-selector-value=".modal-dialog"`、`data-labeler-label-class="modal-open"`は`javascript/labeler_controller.js`の動きをカスタマイズするための引数です。どのモーダル「枠」を制御するか、および開閉指示に使用するCSSクラスを指定しています。
3. `data-action="click->labeler#add"`は、このリンクがクリックされた時に`javascript/labeler_controller.js`の`add()`メソッドを呼び出すように指示します。

実は`labeler_controller.js`はモーダルダイアログだけでなく、CSSクラスの付け外しを担う汎用的なコードとして設計しました。`labeler`と名前を選択しているのもそのためです。そして今回は`.modal-dialog`で指定されたHTML要素に`modal-open`というCSSクラスを付け外ししてもらうのですが、それを指定するのが`data-labeler-selector-value`および`data-labeler-label-class`だったわけです。

ReactではComponentのロジックを再利用したい場合、カスタムフックなどを使います。Stimulus Controllerはカスタムフックと同じように、再利用がしやすいように設計されているというわけです。（もちろん再利用せず、モーダル専用にしても良かったのですが）

**3. モーダルを閉じるボタン**

```html
<button class="p-1 text-sm w-auto hover:cursor-pointer translate-x-2 active:scale-125"
        data-action="click->labeler#remove keydown.esc@window->labeler#remove">
```

上記はモーダルを閉じるボタンです。`click->labeler#remove`の他に、`keydown.esc@window->labeler#remove`があるのがわかります。前者はマウスクリックに対してStimulus controllerの`remove()`を実行してモーダルを閉じるものです。後者な`keydown.esc@window`がついていますが、これは`window`オブジェクトに対する`keydown`イベントを捉え、キーボードショートカットを実装するものです。このようにStimulusを使うと[キーボードショートカットを非常に簡単に実装できます](https://stimulus.hotwired.dev/reference/actions#keyboardevent-filter)。

### まとめ

[Stimulusを使ったデモ](/api/hotwire/modal_w_js)で"Simulus"ボタンをクリックすることでUI/UXを確認できます。CSS loaderのInline JavaScriptを使った場合と動作は同じですが、"ESC"ボタンでモーダルを閉じる機能が追加されています。

* Stimulusを使うとJavaScriptのイベントハンドリングの付け外しが簡単になります
* コードはStimulus controllerにまとめられ、整理されます
* 汎用的なcontrollerを作れば、必要な引数はHTML属性だけで渡せます
* キーボードイベントなどにも簡単に対応できます



<H2WithHash id="react-useeffect">React: useEffectでモーダルを出す方法</H2WithHash>

比較のためにReactのuseEffectでモーダルを出す一般的な方法をおさらいします。[こちらにuseEffectのデモ](/modal)を用意しています。[コードはGitHub](https://github.com/naofumi/hotwire_and_next/tree/main/pages/modal)にあります。

**1. モーダル表示のトリガー**
```tsx
<button className="underline text-orange-600 inline-block active:scale-105"
        onClick={() => setSelectedUserId(i + 1)}>{user.name}</button>
```

`selectedUserId`ステートを変更することがモーダル表示のトリガーになっています。

**2. モーダル表示のJavaScript**
```tsx
{ selectedUserId && <Modal id={selectedUserId} closeModal={() => setSelectedUserId(null)} />}
```

`selectedUserId`による[条件付きレンダー](https://ja.react.dev/learn/conditional-rendering)で`Modal`コンポーネントの表示・非表示を切り替えています。`Modal`コンポーネントには`id`と`closeModal`のpropsを渡していますが、`closeModal`は`setSelectedUserId`を`null`にして、モーダルを閉じるものになっています。

**3. モーダル表示内容の取得 components/Modal.tsx**

```tsx
export default function Modal({closeModal, id}: {
  closeModal: () => void,
  id: number,
}) {
  const [userDetail, setuserDetail] = useState<User & UserDetail | null>(null);

  useEffect(() => {
    setuserDetail(null)
    fetch(`/api/user?id=${id}`).then(res => res.json())
      .then(data => {
        setuserDetail(data)
      })
  }, [id])

  return <>
<div>
  <div className="p-1 text-sm w-auto hover:cursor-pointer translate-x-2 active:scale-125"
       onClick={closeModal}>
    ...
  </div>
</div>
<div className="mt-5 sm:mt-6">
  {
    !userDetail
      ? <div>
        <Image src={rocketImage} alt="loader" className="m-auto mt-10 w-16 h-16"/>
      </div>
      : <div>
        ...[モーダルの内容]...
      </div>
  }
</div>
  </>
}
```

React useEffectの場合、元のページでやるのは条件付きレンダーだけです。サーバにリクエストを投げて、結果を表示するなどの実質的な処理は全て`Modal`コンポーネントの中でやります。

`Modal`コンポーネントが読み込まれると、`useEffect()`の中の`fetch()`でサーバからデータを取得します。レスポンスが帰って来れば、これを`userDetail`ステートの入れて画面に表示します。

またサーバからデータが得られていない時点では`userDetail`が`null`なので、この間はローディング画面を表示します。

### まとめ

[useEffect](/modal)のデモでもご覧いただけるように、ちゃんとフィードバックのあるUI/UXが実現できています。コードも少なく、流れが直感的にわかります。HotwireでJavaScriptを使用した場合と同じような感じになっています。

<H2WithHash id="react-client-components">React: Client Componentsでモーダルを出す簡易法</H2WithHash>

ReactではRSC(React Server Components)が話題になっていますので、Client Componentを使ってモーダルを作ってみました。[こちらにClient Componentのデモ](/modal_app_client)を用意しています。[コードはGitHub](https://github.com/naofumi/hotwire_and_next/tree/main/app/modal_app_client)にあります。

結論から言うと、[useEffectでモーダルを出す場合](/commentaries/modal_dialogs#react-useeffect)とほとんど差がなく、ほぼ同じ結果になりました。何か固有の書き方を見逃しているかもしれませんが、RSCの話題もServer Componentがほとんどですので、おそらくClient Component側はほぼ変わっていないという理解で良いかと思います。

<H2WithHash id="react-server-components">React: Server Componentsでモーダルを出す簡易法</H2WithHash>

モーダルはインタラクティブな要素ですので、上記のようにClient Componentで作るのが王道に思えます。公式ドキュメントでもClient Componentのメリットを下記のように紹介しています。

> **Interactivity:** Client Components can use state, effects, and event listeners, meaning they can provide immediate feedback to the user and update the UI.

一方で[Parallel RoutesとIntercepting Routesを使って、Server Componentでモーダルを実現](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#modals)する例も紹介されています。

そこで、ここでは実際にServer Componentでモーダルを作って見ながら、そのUI/UXやコードの複雑さを確認したいと思います。ただしIntercepting routesとParallel routesを一度にやるのは流石に複雑なので、最初に[簡易法](#react-server-components)を紹介し、次に[Layoutを使った方法](https://nextjs.org/docs/app/building-your-application/routing/layouts-and-templates#layouts)を紹介します。Intercepting routesとParallel routesはさらにこの２つの先にある手法だと思っていて、いきなりは紹介できないと思ったからです。なお最初に示す[簡易法は私のここのブログ記事で知りました](https://medium.com/@dtulpa16/next-js-modals-made-easy-7bdce15b2a5e)。

### コード

**1. モーダルの表示 app/modal_app/page.tsx**

```tsx
async function getUsers(): Promise<User[]> {
  console.log("Fetch start for Users")
  const res = await fetch(process.env.URL + "/api/users")
  const users = await res.json()
  return users
}

export default async function ModalAppPage({searchParams}: { searchParams: { userId: string | undefined } }) {
  const userId = searchParams.userId
  const users = await getUsers()

  return (
    <>
      ...[ページのコンテンツはここ]...
      <Link href={`/modal_app?userId=${user.id}`}
            className="underline text-orange-600 inline-block active:scale-105"
            scroll={false}>
        {user.name}
      </Link>
      ...[ページのコンテンツはここ]...
      {userId && <Modal userId={userId}/>}
    </>
  )
}
```

仕組みとしては下記のような簡単なものです。

1. `/modal_app`でこのページにアクセスした場合はモーダルが表示されない
3. `/modal_app?userId=1`でこのページにアクセスした場合は、userId=1のUserの情報がモーダルに表示される

これを実装するために以下のロジックになっています。
1. `Link`タグのところをクリックすると、`/modal_app?userId=1`などに遷移します
2. `userId = searchParams.userId`のところで、URLの`?userId=1`の箇所を読み取り、`userId`変数に格納します
3. 最後の`{userId && <Modal userId={userId}/>}`で条件付きレンダーをして、`userId`がセットされている場合は`Modal`コンポーネントを表示します

なお`Link`タグには`scroll={false}`がありますので、リンク先に遷移する場合でもスクロール位置が変わらず、元の画面のステートが保たれます。

このように、「モーダルだけ」を表示するように見せかけているが、実際にはページ全体が再表示されています。でもネットワークが速い場合は全く気になりません。

**2. モーダルのクローズ app/modal_app/components/Modal.tsx**

```tsx
export default async function Modal({userId}: { userId: string }) {
  const userDetail = await getUserDetails(userId);

  return (
    ...[モーダルの内容]...
      <Link className="p-1 text-sm w-auto hover:cursor-pointer translate-x-2 active:scale-125"
            href={`/modal_app`}
            scroll={false}
            prefetch={true} >
        ...[ボタンのイメージ]...
      </Link>
    ...[モーダルの内容]...
  )
}
```

モーダルを閉じるところは上記のようになっています。

一番最初に紹介した[カスタムJavaScriptの例](#turbo-without-custom-javascript)と非常によく似ています。React Server Componentsは`Link`と`form`で稼働されるServer Action以外はJavaScriptのイベント処理がありませんので、`onclick`などが使えません。通常の`Link`をトリガーにしてモーダルを閉じるしかありません。

ここでは`/modal_app`にリンクしています。`/modal_app`は**1.**で示した通り、モーダルを表示しません。実際には画面全体が再表示されているのですが、ユーザにとってはモーダルだけが消えたように見えます。

### UI/UX

[Server Componentsでモーダルを出す簡易法のデモはこちら](http://localhost:3000/modal_app)で、[コードはGitHub](https://github.com/naofumi/hotwire_and_next/tree/main/app/modal_app)にあります。

* サーバのレスポンスタイムが300ms程度であれば、快適なUI/UXになります。これは[カスタムJavaScriptの例](#turbo-without-custom-javascript)の例と同じです
* ただしレスポンスタイムを2000msに設定するともたつきを感じます。モーダルを表示する時も、そしてモーダルを閉じる時もフィードバックがなく、ユーザは不安を感じてしまいます。

### まとめ

* コードは非常にシンプルです。これ以上シンプルにはできないぐらいにシンプルです
* サーバのレスポンスタイムが早ければ、この簡易法でも十分快適なUIを提供してくれます
* しかしサーバのレスポンスが遅い可能性がある場合は、違う方法を使った方が良いでしょう


<H2WithHash id="react-server-components-with-layouts">React: Server Components + Layout</H2WithHash>

Server Componentを使ったもう１つの方法を紹介します。[Layout](https://nextjs.org/docs/app/building-your-application/routing/layouts-and-templates#layouts)を使用します。

React Server ComponentsではページのコンテンツをRSC payloadというフォーマットでサーバからブラウザに送信します。

[公式ドキュメントより RSC Payloadについて](https://nextjs.org/docs/app/building-your-application/rendering/server-components#what-is-the-react-server-component-payload-rsc)
> The RSC Payload is a compact binary representation of the rendered React Server Components tree. It's used by React on the client to update the browser's DOM. The RSC Payload contains:
> * The rendered result of Server Components
> * Placeholders for where Client Components should be rendered and references to their JavaScript files
> * Any props passed from a Server Component to a Client Component

私の理解では、これはHotwireがサーバから送るHTMLと非常によく似ています。違いはClient Componentとの接続インタフェースが用意されていることぐらいに思えます。したがってページの部分置換をするには、Turbo Framesのように、レンダーされた結果を入れ替える仕組みが必要になってきます。

今のところ、Next.jsでTurbo Framesのような部分置換機能を提供しているのは`Layout`だけではないかと思います。`Parallel routes`もありますが、これは`Layout`を拡張したもので、実質的には同じものではないかなと思っています。

### コード

[コードはGitHubに掲載](https://github.com/naofumi/hotwire_and_next/tree/main/app/modal_app_layout)しています。

パーツが多いので、概要だけ示します

1. [`layout.tsx`](https://github.com/naofumi/hotwire_and_next/blob/main/app/modal_app_layout/layout.tsx): 少しわかりにくいのですが、Next.jsのLayoutの仕組みでは、部分置換をしても変わらない部分は`layout.tsx`に配置します。今回のケースではUserのリストは`layout.tsx`に表示します。また`layout.tsx`にはモーダルを表示するための「窓」を`{children}`として用意しています。
2. [`page.tsx`](https://github.com/naofumi/hotwire_and_next/blob/main/app/modal_app_layout/page.tsx): ブラウザが`/modal_app_layout`にアクセスした時、上記の`layout.tsx`の`{children}`に差し込まれるのが`page.tsx`です。モーダルを出さないため、何も表示しませんので、`null`を返します
3. [`modal/[userId]/page.tsx`](https://github.com/naofumi/hotwire_and_next/blob/main/app/modal_app_layout/modal/%5BuserId%5D/page.tsx): ブラウザが`/modal_app_layout/modal/1`にアクセスした時、上記の`layout.tsx`の`{children}`に差し込まれる内容です。`[userId]`の内容を読みとり、モーダルの枠およびUserのデータを返します
4. [`modal/loading.tsx`](https://github.com/naofumi/hotwire_and_next/blob/main/app/modal_app_layout/modal/loading.tsx): ブラウザが`/modal_app_layout/modal/1`にリクエストを投げ、レスポンスを待っている間に`layout.tsx`の`{children}`に差し込まれる内容です。ローディングアニメーションを含んでいます。

コードの詳細の解説は今回は省略させていたきます。モーダルを表示するトリガー、モーダルを閉じるボタンなども併せてご確認いただけると理解が深まるかなと思います。

### UI/UX

* サーバのレスポンスが速い場合は、簡易法と同様の快適なUI/UXが実現できています
* サーバのレスポンスが遅くても、モーダルを表示させる際はすぐにローディングアニメーションが表示され、フィードバックが得られます。十分なUI/UXが提供できています
* モーダルを閉じる場合は、サーバのレスポンスが遅いともたつきます。フィードバックがなく、しばらく経ってからモーダルが消えるだけです。良くないUI/UXです。これについては何か工夫をすると改善できるかもしれませんが、私にはわかりませんでした

### まとめ

* 必要なファイル数が多く、それぞれの役割を理解するのが大変です。複雑で直感的ではないと言えます。特にUserのリストを`layout.tsx`に記述しなければならないのはわかりにくいです
* 簡易法と比べて、モーダルを表示する時はUI/UXが改善されています
* サーバのレスポンスが遅いケースでモーダルを閉じる際、UI/UXに問題が出てきます

何よりもコードが複雑なのがこのアプローチの欠点だと思います。[Parallel routes](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes)や[Intercepting routes](https://nextjs.org/docs/app/building-your-application/routing/intercepting-routes)を使うことでUI/UXが改善する可能性はありますが、今回のLayoutと比べてさらにコードは複雑になります。したがって現時点でおすすめはできません。

<H2WithHash id="summary">各技術のまとめ</H2WithHash>

今回は大きく分けて６通り、細かく分けると８通りのモーダルダイアログの出し方を検討しました。これでも全然網羅的ではなく、他の方法もきっとあるはずです。その中で以下のことが言えるのではないかと思います。

* Turbo Framesを使用する場合、JavaScriptなしで非常に簡単に実装することができます。しかし、もう少しだけ頑張ってカスタムJavaScriptおよびCSSを書けば、使い回し可能でUI/UXが優れたモーダルダイアログが作れます。なるべくならば少し手間をかけてここまでやっていただければと思います
* Reactを使う場合は、`useEffect`などを使ってブラウザでJavaScriptを動かし、ブラウザでデータをフェッチするのが良さそうです。コードも簡単でわかりやすく、UI/UXも優れています
* React Server Componentsを使った例がNext.jsの公式サイトに紹介されていますが、コードのわかりやすさとUI/UXを総合的に加味すると、現時点ではお勧めするのは難しいと思います

export default function ModalDialogs({children}) {
  return <CommentaryLayout
    title="Modal Dialogs"
    subtitle="モーダル"
    section="Commentary">
    <MDXRenderer>{children}</MDXRenderer>
  </CommentaryLayout>
}
