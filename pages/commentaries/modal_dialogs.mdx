import MDXRenderer from "../../components/MDXRenderer";
import CommentaryLayout from "../../components/CommentaryLayout";
import hotwireJavascriptImage from "@/public/images/hotwire-javascript.webp"
import Image from "next/image"

モーダルダイアログはUI要素としてウェブデザインで非常によく使われます。よって**簡単にモーダルダイアログが作れることが開発者としては重要**です。

HTMLには[`dialog`タグ](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dialog)も用意されていますので、表示自体は難しくありません。ただし内容をサーバからロードする場合は**ネットワーク遅延への対応**などが発生します。これにうまく対応するか否かでUI/UXに差が出てきます。

下記ではUXおよび実装の簡単さを重視しつつ、モーダルダイアログの作り方を複数検討します。Hotwireに加え、**Next.jsのApp RouterとPages Routerについてもモーダルの出し方を検討し**、比較します。また`dialog`タグを使わずに、従来のHTML/CSSの組み合わせでモーダルダイアログを作ります。

## Turbo Frames: カスタムJavaScriptなし===turbo-without-custom-javascript===

まずはHotwire/Turbo Framesを使って、カスタムのJavaScriptを書かずにモーダルを出す方法を紹介します。**「Hotwireを使うとJavaScriptなしでモーダルダイアログが作れる」という話はよく聞きますが、その時に使われている手法です**。

[カスタムJavaScriptなしのデモはこちら](/api/hotwire/modal_no_js)に用意しています。また[コードはGitHub](https://github.com/naofumi/hotwire_and_next/tree/main/pages/api/hotwire/modal_no_js)にあります。

サーバから動的な内容をモーダルを表示する際は、通常は２つステップが必要です。

1. モーダルを表示する (カスタムJavaScriptで行う: HotwireならStimulus)
2. モーダルのコンテンツをサーバにリクエストし、結果をモーダル内に表示する (AJAX/fetchで行う: HotwireならTurbo Framesがすべての処理をしてくれます)

しかし、サーバからの**レスポンスと一緒にモーダルの「枠」も同時に送り返せば、モーダルを開くJavaScriptが必要なステップ1.は省略可能**になります。これがこの方法の特徴です。

### コード ===code-wo-custom-javascript===

必要なコードは以下のものになります。ただしコントローラアクションは一般的なものなので、解説を省略します(`pages/api/hotwire/modal_no_js`)。

#### モーダルの「枠」とコンテンツのHTMLページ

**templates/modal_no_js/modal.ejs**
```html
<turbo-frame id="modal">
   ...[モーダルのコンテンツおよびモーダルの枠]...
</turbo-frame>
```
* これはモーダルの中に表示する内容 + モーダルの「枠」です
* ブラウザからのTurbo Framesリクエストを受けて、サーバからブラウザに送信されます
* `<turbo-frame id="modal">`がありますので、ブラウザはこれを受信すると、ブラウザですでに表示されている`<turbo-frame id="modal">`の箇所を置換します

#### モーダル表示のトリガー

**templates/modal_no_js/index.ejs**
```html
<a href="/api/hotwire/modal_no_js/modal?id=<%= user.id %>"
   data-turbo-frame="modal"
   class="text-orange-600 underline inline-block active:scale-105"><%= user.name %></a>
```

* `a`タグをクリックすると、`/api/hotwire/modal_no_js/modal?id=1`からモーダルの中身(HTML)がダウンロードされます
* ダウンロードされたHTMLは`<turbo-frame id="modal">`がありますので(上述)、ブラウザですでに表示されている`<turbo-frame id="modal">`の箇所を置換します）

#### モーダルHTML断片の差し込み先

**templates/modal_no_js/index.ejs**
```html
<turbo-frame id="modal"></turbo-frame>
```

* サーバからダウンロードされたHTMLをここに挿入しなさいという指示になります

#### モーダルを閉じるボタン

**templates/modal_no_js/modal.ejs**
```html
<a class="p-1 text-sm w-auto hover:cursor-pointer translate-x-2 active:scale-125"
     href="/api/hotwire/modal_no_js">
```
* 今回はカスタムJavaScriptを敢えて避けますので、`onclick`等のイベントハンドラが使えません。ブラウザのインタラクションは`a`タグや`form`タグに限定されます
* そこで`a`タグを使用して、モーダル表示前のページをリクエストしています。その結果、モーダルが閉じたように見えます

ブラウザが受け取るHTMLレスポンスには空の`turbo-frame`が含まれています。Turbo Framesはブラウザに表示されている既存の`turbo-frame`をこの空の`turbo-frame`に入れ替えます。その結果、ブラウザに表示されている`turbo-frame`の中身は空になり、枠も無くなるのでモーダルが閉じます。ブラウザが受け取るHTMLは`turbo-frame`だけではなく、`templates/modal_no_js/index.ejs`のすべてですが、画面に反映される（差し込まれる）のは`turbo-frames`の中身(空)だけであることに注意してください。

### UI/UX  ===UI-wo-custom-javascript===

[カスタムJavaScriptなしで作ったデモ](/api/hotwire/modal_no_js)を用意していますので、ご覧ください。[トップページ](/)からで遅延を設定できますので、300msの場合と2000msの場合を比較してください。

* サーバのレスポンスが十分に速い場合(300msの場合)は快適です。
* しかし遅延を2000msに設定するとUI/UXの弱点が見えてきます。リンクを押してもフィードバックがなく、ユーザはシステムが正しく動作している自信が持てません。またモーダルを閉じる時も遅延が発生します。「閉じるだけなら瞬間的に行くのでは？」というユーザの期待と反して、サーバからレスポンスが返ってくるまでモーダルは閉じません。<br />(リンク等をクリックした時にCSS `:active`を使っていますが、十分なフィードバックとは言えません)

### まとめ  ===summary-wo-custom-javascript===

* カスタムJavaScriptなしの場合はコードが非常に簡素で、直感的にもわかりやすいものになります
* しかし、**特にネットワークが遅い場合は、ユーザの操作に対するフィードバックが弱く、良いUI/UXとは言えません**
* モーダルが開いた状態でブラウザをリロードすると、モーダルの中身だけを表示した「詳細ページ」見たいなものを表示できます。モーダルの中身をリンクで共有したり、SEOでモーダルの内容を検索エンジンにインデックスさせたい場合に有利です。[Next.js App RouterのIntercepting Routes](https://nextjs.org/docs/app/building-your-application/routing/intercepting-routes)と同じことが実現されています


## Turbo Frames: Inline JavaScript ===turbo-with-custom-javascript===

上記の[Turbo Frames: カスタムJavaScriptなし](http://localhost:3000/commentaries/modal_dialogs#turbo-without-custom-javascript)の問題点を解消し、ネットワークが遅い場合でも十分なUI/UXを提供するためには、レスポンスが来る前にフィードバックを提供する必要があります。そのためには**ボタンを押した瞬間に起動するカスタムJavaScriptが必要です**。

上記ではモーダルの「枠」をサーバから送ることでモーダルを開くステップを省略していました。しかしここでは**カスタムJavaScriptを使って、サーバレスポンスの遅延の有無に関わらず、リクエストを投げた瞬間にモーダルを開きます**。これがユーザに対するフィードバックとなり、UI/UXの改善に繋がります。

なおHotwireでカスタムJavaScriptを書く場合は、一般には[Stimulus](https://stimulus.hotwired.dev)を使います。しかし**最初はとっつきにくいので、まずはインラインJavaScriptを使った例から紹介します**。

### コード ===code-inline-javascript===

カスタムJavaScriptなしの場合と比較して、以下のコードが追加されます。

* サーバからのレスポンスを待たずにモーダルを表示するため、モーダル「枠」HTMLをあらかじめ元のページに挿入しておきます。ただしCSSで隠して見えなくします。この中にサーバから受け取るHTML断片を差し込む目印の`turbo-frame`を入れておきます
* モーダルの表示をトリガーするカスタムJavaScriptの設置。Turboがサーバにリクエストを投げるのは前回と変わらないのですが、これとは独立にモーダルを即時表示するJavaScriptを用意します。
* モーダルを閉じるボタンがJavaScriptを呼び、モーダルだけが閉じるようにします。

#### モーダルの「枠」だけ

**templates/modal_w_js/index.ejs**
```html
  <div class="modal-dialog relative z-10" aria-labelledby="modal-title" role="dialog" aria-modal="true">
    <div class="modal-backdrop fixed inset-0 bg-gray-500 bg-opacity-75 transition-opacity" aria-hidden="true"></div>

    <div class="modal-panel fixed inset-0 z-10 w-screen overflow-y-auto">
      <div class="flex min-h-full items-end justify-center p-4 text-center sm:items-center sm:p-0">
            ...
            <div class="!min-w-64 !min-h-40 mt-5 sm:mt-6">
              <turbo-frame id="modal" class="turbo-with-loader no-delay">
                <div class="turbo-hide-on-loading ">
                  Loading...
                </div>
              </turbo-frame>
            </div>
            ...
      </div>
    </div>
  </div>
```

**`hotwire/styles/input.css`**
```css
    .modal-dialog .modal-backdrop {
        @apply ease-out duration-300 opacity-0 invisible
    }

    .modal-dialog.modal-open .modal-backdrop {
        @apply ease-out duration-200 opacity-100 visible
    }

    .modal-dialog .modal-panel {
        @apply ease-out duration-300 translate-y-4 sm:translate-y-0 sm:scale-95 opacity-0 invisible
    }
```

* モーダルの「枠」が最初からページに埋め込まれています。そして通常は非表示になるようにCSSを用意します。
* 「枠」の中に`<turbo-frame id="modal">`が含まれています

#### モーダルの内容だけを含むHTMLページ:

**templates/modal_w_js/modal.ejs**
```html
<turbo-frame id="modal">
   ...[モーダルのコンテンツ]...
</turbo-frame>
```

* モーダルの中身だけです。枠は上述で最初のページに(非表示で)埋め込んでいますので、ここには含めません。純粋にモーダルの中身だけです
* サーバにリクエストを投げると、返ってくるのはこのテンプレートの内容です
* `<turbo-frame id="modal">`がありますので、ブラウザがこのページを受け取ると、すでに表示されている`<turbo-frame id="modal">`の箇所をこの内容で置換します


#### モーダル表示のJavaScript

**templates/modal_w_js/index.ejs**
```html
<script>
  function openModal() {
    const turboFrame = document.querySelector("turbo-frame#modal")
    turboFrame.innerHTML = '<div>Loading... </div>'
    const modal = document.querySelector(".modal-dialog")
    modal.classList.add("modal-open")
  }

  function closeModal() {
    const modal = document.querySelector(".modal-dialog")
    modal.classList.remove("modal-open")
  }
</script>
```

* 最初のページに埋め込まれた「枠」はCSSで**非表示**になっていました。ここのコードはその「枠」を**表示させる**ものです
* JavaScriptは`script`タグで囲んでインラインで書いています。通常であればStimulusを使うのですが、ここでは説明するためのわかりやすさを優先し、インラインJavaScriptを使っています。
* 最初のページに埋め込まれた「枠」に`.modal-open`のCSSクラスをつけたり外したりするだけです
* さらに`openModal()`では、`turbo-frame`の"Loading..."と表示させ、ローディング中の表示をさせています。内容が異なっても同じモーダルを使うので、毎回リフレッシュするためです。これをやらないと前回開いた時の内容が一瞬モーダル内に表示されてしまいます

#### モーダル表示のトリガー

**templates/modal_w_js/index.ejs**
```html
<a href="/api/hotwire/modal_w_js/modal?id=<%= user.id %>"
   data-turbo-frame="modal"
   onclick="openModal()"
   class="text-orange-600 underline inline-block active:scale-105">
  <%= user.name %>
</a>(Inline JS)<br>
```

* `a`タグをクリックするとモーダルを表示するようにしています。`onclick`属性で`openModal()`を呼び出して、モーダルを表示させています
* この`a`タグは`data-turbo-frame="modal"`属性もありますので、同時に`href`で指定したエンドポイントにリクエストを飛ばし、返ってきたHTMLを`turbo-frame id="modal"`に差し込みます。ここは上述の「カスタムJavaScriptなし」のケースと同じです

「カスタムJavaScriptなし」のケースと大きく異なるのは、`a`タグにこの２つの属性をつけることで、モーダルを表示させるコードとTurbo Frameにデータを読み込むコードを分割したことです。そのため、サーバからのレスポンスが遅延しても、それとは無関係に先にモーダルを表示しています

**「モーダルの開閉」と「サーバからのデータの読み込み」を独立させたことにより、UXを大幅に改善しているわけです**。

#### モーダルを閉じるボタン

**templates/modal_w_js/modal.ejs**
```html
<button class="p-1 text-sm w-auto hover:cursor-pointer translate-x-2 active:scale-125"
        onclick="closeModal()">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"
       class="mx-auto size-6 text-orange-600">
    ...
  </svg>(Inline JS)
</button>
```

* `button`タグでモーダルを閉じます。`onclick="closeModal()"`がありますので、これが先ほど用意した`closeModal()`を呼び出して、モーダルを閉じています。
* [カスタムJavaScriptを使わない例](/commentaries/modal_dialogs#turbo-without-custom-javascript)と異なり、モーダルの開閉とサーバからのデータの読み込みが分かれていますので、モーダルだけ瞬時に閉じられます

### UI/UX ===ui-inline-javascript===

[JavaScriptを使った例のデモを用意しています](/api/hotwire/modal_w_js)ので、お試しください。他の例も同じデモ画面に含めていますので、"Inline Javascript"のUI/UXを確認する場合は、**"Inline JS"と書いてあるボタンを押してください。**

* モーダルダイアログは瞬時に表示されます
* サーバのレスポンスが遅い場合は"Loading..."と表示されますので、リクエストが送信され、サーバのレスポンス待ちであることがわかります。ユーザへのフィードバックが適切にされていますので、UI/UXは良くなっています。
* クローズボタンを押したときにモーダルダイアログは瞬時に閉じます。これはユーザの期待に沿いますので、UI/UXは良くなっています。

### まとめ ===summary-inline-javascript===

* カスタムJavaScriptなしの例に比べて多少はコードが増えていますが、10行程度です
* モーダル「枠」はサーバから送信されるのではなく、元のページに含まれています
* サーバレスポンスが遅延していても優れたUI/UXを提供できます

Turbo Framesを使うと[カスタムJavaScriptなし](commentaries/modal_dialogs#turbo-without-custom-javascript)でもモーダルが作れます。宣伝文句としてはインパクトがあるせいか、このやり方を非常に多く見かけるように思います。しかしHotwireがStimulusとセットになっていることからも分かるように、**HotwireはむしろカスタムJavaScriptを書くことを奨励しています。Hotwire流とはJavaScriptを全く書かないことではなく、JavaScriptをたくさん書かないことです**。そしてここで確認したように、わずか10行程度のJavaScriptでUI/UXを大きく改善できました。

ぜひ「JavaScriptなし」の宣伝文句に踊らされず、UI/UXを改善するたも少量の簡単なJavaScriptを使うようにしていただければと思います。

<Image src={hotwireJavascriptImage} alt="hotwire-without-much-javascript" className="w-1/2 block mx-auto" />

## Turbo Frames: CSSローディングアニメーション ===turbo-css-loader===

[Inline JavaScript](#turbo-with-custom-javascript)の項では、カスタムJavaScriptを使ったおかげでモーダルが瞬時に表示されるようになりました。つまりサーバからのレスポンスよりも前にモーダルが表示されます。空白のモーダルを表示するのは不親切ですので、何らかのローディングアニメーションが欲しいところです。

前の項では単純に"Loading..."の文字列をJavaScriptで差し込みました。これでも良いのですが、Turboはロード中に`busy`のHTML属性を自動的に付けてくれますので、CSSだけでもローディングアニメーションを表示できます。ここではこの方法を紹介します。

### コード ===code-turbo-css-loader===

デモで使用しているコードはもう少し複雑ですが、ポイントを下に記しました。

**hotwire/styles/input.css**
```css
.turbo-with-loader .turbo-hide-on-loading {
    /*　GIFイメージは`position: absolute`で配置するので、
        ここを`position: relative` にする*/
    position: relative;
}

.turbo-with-loader .turbo-hide-on-loading::before {
    visibility: hidden !important;
    opacity: 0 !important;
}

.turbo-with-loader[busy] .turbo-hide-on-loading {
    visibility: hidden !important;
}

.turbo-with-loader[busy] .turbo-hide-on-loading::before {
    content: '';
    visibility: visible !important;
    opacity: 1 !important;
    position: absolute !important;
    display: block;
    background-image: url('../../images/rocket.gif');
    width: 64px;
    height: 64px;
    top: 40px;
    left: 50%;
    transform: translateX(-50%);
}
```

* `turbo-frame`には`turbo-with-loader`CSSクラスを付けています。
* アニメーション表示のときに隠したい部分を`turbo-hide-on-loading`で囲っています。ここの`::before`擬似要素にローディングのGIFアニメーションを表示します
* アニメーションの表示・非表示は`turbo-with-loader`CSSクラスがついている`turbo-frame`の`busy`属性で切り替えます(`.turbo-with-loader[busy]`セレクタ)。`busy`なら隠したい部分(`turbo-hide-on-loading`を持つ)が非表示になり、かつ`::before`のところのGIFアニメーションが表示されます
* 結論として、`turbo-with-loader`と`turbo-hide-on-loading`を適切にHTMLに付けてあげるだけでローディングアニメーションが動きます

### UI/UX ===ui-turbo-css-loader===

[デモ画面](/api/hotwire/modal_w_js)の"CSS loader"と付いているボタンを押してください。このボタンを使うと、`turbo-hide-on-loading`がついたHTML要素が使われ、適切にアニメーションが動きます。特にサーバレスポンスを遅延させてお試しください。

* モーダルが表示されると中にアニメーションが表示され、システムが正しく動作している安心感をユーザに与えます。良いUI/UXです

### まとめ

* Turbo Framesは動作中に`turbo-frame`要素に[`busy`属性を付けてくれます](https://turbo.hotwired.dev/reference/frames#html-attributes)([`busy-aria`属性も付けてくれます](https://turbo.hotwired.dev/reference/attributes#automatically-added-attributes))
* これを使うと、ローディングアニメーションをCSSだけで実装できます
* [Inline Javascript](/commentaries/modal_dialogs#turbo-with-custom-javascript)で紹介したように、`openModal()`の中でHTMLを直接いじり、"Loading..."を表示させることもできます。適宜使い分けていただくのが良いと思います。


## Stimulusでイベント処理を改善 ===turbo-with-stimulus===

上記のように、Turbo FramesとカスタムJavaScriptおよびCSSを使うと、かなりUI/UXの良いモーダルダイアログが作成できます。サーバからリクエストを受け取ってデータを表示しているにも関わらず、必要なコードは少なく、処理の流れも直感的でわかりやすくなっています。

しかしHTMLの`onclick`属性を使用しているところは問題です。`onclick`属性等の[インラインのイベントハンドラーはとても使いやすいのですが、一般には使用するべきではないとされています](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#inline_event_handlers_—_dont_use_these)。そこでここではHotwireに含まれる[Stimulus](https://stimulus.hotwired.dev)を使います。

Stimulusは下記の特徴があります。

* AJAX/fetchをするページでのイベントハンドラー処理を完全自動化。[`addEventListener()`](https://developer.mozilla.org/en-US/docs/Web/Events/Event_handlers#eventtarget.addeventlistener)より使い勝手が良い
* HTMLとJavaScriptの関連が分かりやすくなる
* JavaScriptコードの再利用性が高まるような設計の工夫がされている
* キーボードイベントなどの処理も簡略化

<p className="text-gray-400 text-sm">Stimulusは[DOM MutationObserver APIを使用してDOMの変更を監視](https://stimulus.hotwired.dev/reference/lifecycle-callbacks#order-and-timing)し、そのタイミングでイベントハンドラーを接続します。従来は`load`イベントを受け取り`element.addEventListener()`を使うことが多かったが、SPAでは`load`イベントが発火しないために問題があります。動的に読み込まれる要素が多いウェブページであっても、Stimulusは確実にかつ簡単にイベントハンドラーを接続してくれます。なおReactの場合は`useEffect`を使ってコンポーネントがロードを検知できるので、SPAの`load`問題を回避できています</p>

<p className="text-gray-400 text-sm mt-2">Stimulusを使うと、コードを小さいコントローラに分割することが強要されますので、コードの整理整頓につながります。また`data-controller="..."`属性をHTML側につけますので、どのHTML要素がどのStimulus Controllerを呼び出すのが明快です。jQueryや素JavaScriptの`addEventListener()`を多用した場合はこれがわかりにくくなることあり、それと比較すると大きな改善です</p>

今回は各ポイントに軽く触れながら、Stimulusで書いたコードを紹介します。[CSSローディングアニメーションをつけたデモ](#turbo-css-loader)をベースに話します。

### コード ===code-turbo-with-stimulus===

#### モーダル表示のトリガー

**templates/modal_w_js/index.ejs**
```html
<div class="inline-block min-w-full py-2 align-middle sm:px-6 lg:px-8"
     data-controller="labeler"
     data-labeler-selector-value=".modal-dialog"
     data-labeler-label-class="modal-open"
>
  ...
  <a href="/api/hotwire/modal_w_js/modal?id=<%= user.id %>"
     data-turbo-frame="modal"
     data-action="click->labeler#add"
     class="text-orange-600 underline inline-block active:scale-105">
    <%= user.name %>
  </a>(Stimulus)
  ...
</div>
```

* モーダル表示のトリガーです。`a`タグをクリックしたときにモーダルが表示されます
* モーダル表示の処理をするJavaScriptはStimulus Controller(`public/hotwire/javascript/labeler_controller.js` 下で解説)のに記述されています。`data-controller`, `data-labeler-selector-value`, `data-labeler-label-class`, `data-action`のHTML属性の組み合わせにより、**2.** のコードが呼び出されています
    * `data-controller="labeler"`は、この`div`タグに囲まれている部分を`javascript/labeler_controller.js`に繋げます
    * `data-labeler-selector-value=".modal-dialog"`、`data-labeler-label-class="modal-open"`は`javascript/labeler_controller.js`の動きをカスタマイズするための引数です。どのモーダル「枠」を制御するか、および開閉指示に使用するCSSクラスを指定しています。一見すると冗長ですが、これによって他の場面でも同じStimulus Controllerが使用でき、再利用性が高まります
    * `a`タグをクリックすると、`data-action="click->labeler#add"`属性の指示により、Stimulus Controllerの`add()`メソッドが呼び出されます

#### Stimulus Controller – モーダル表示のJavaScript

**public/hotwire/javascript/labeler_controller.js**
```js
import {Controller} from "/hotwire/javascript/stimulus.js"

export default class extends Controller {
  static values = {"selector": String}
  static classes = ["label"]

  add() {
    const labelable = document.querySelector(this.selectorValue)
    labelable.classList.add(this.labelClass)
  }

  remove() {
    const labelable = document.querySelector(this.selectorValue)
    labelable.classList.remove(this.labelClass)
  }
}
```

* `add()`メソッドは`this.selectorValue`で指定されたDOM要素に、`this.labelClass`で指定されたCSSクラスをつけます。`remove()`は逆にCSSクラスを外します
* 上の`this.selectorValue`および`this.labelClass`は、それぞれ上述の「モーダル表示のトリガー」で指定した`data-labeler-selector-value=".modal-dialog"`および`data-labeler-label-class="modal-open"`の値が入ってきています
* 上述の「モーダル表示のトリガー」の`a`タグの`data-action="click->labeler#add"`により、クリック時に`add()`が呼び出されます

#### モーダルを閉じるボタン

**templates/modal_w_js/index.ejs**
```html
<button class="p-1 text-sm w-auto hover:cursor-pointer translate-x-2 active:scale-125"
        data-action="click->labeler#remove keydown.esc@window->labeler#remove">
```

* モーダルを閉じるボタンです
* `button`タグの`data-action="click->labeler#remove"`により、クリックされると上述のStimulus Controllerの`remove()`メソッドが実行され、モーダルを閉じます
* さらに`button`タグの`data-action="keydown.esc@window->labeler#remove"`により、`window`に`keydown`イベントハンドラーが接続されていますので、Escキーが押されたときにStimulus Controllerの`remove()`が呼び出され、モーダルを閉じてくれます

このようにStimulusを使うと[キーボードショートカットを非常に簡単に実装できます](https://stimulus.hotwired.dev/reference/actions#keyboardevent-filter)。

### まとめ  ===summary-turbo-with-stimulus===

[Stimulusを使ったデモ](/api/hotwire/modal_w_js)で"Simulus"ボタンをクリックすることでUI/UXを確認できます。CSS loaderのInline JavaScriptを使った場合と動作は同じですが、"ESC"ボタンでモーダルを閉じる機能が追加されています。

* Stimulusを使うとJavaScriptのイベントハンドリングの付け外しが簡単になります
* コードはStimulus controllerにまとめられ、整理されます
* 汎用的なcontrollerを作れば、必要な引数はHTML属性だけで渡せます
* キーボードイベントなどにも簡単に対応できます

## React: useEffectでモーダルを出す方法 ===react-useeffect===

比較のためにReactのuseEffectでモーダルを出す一般的な方法をおさらいします。[こちらにuseEffectのデモ](/modal)を用意しています。[コードはGitHub](https://github.com/naofumi/hotwire_and_next/tree/main/pages/modal)にあります。

### コード ===code-react-useeffect===

#### モーダル表示のトリガー

**pages/modal/index.tsx**
```tsx
export default function ModalIndex({users}: {users: User[]}) {
  const [selectedUserId, setSelectedUserId] = useState<number | null>(null);

  return (
    <Layout>
        <>
          ...
          <button className="underline text-orange-600 inline-block active:scale-105"
                  onClick={() => setSelectedUserId(i + 1)}>{user.name}</button>
          ...
        </>
      { selectedUserId && <Modal id={selectedUserId} closeModal={() => setSelectedUserId(null)} />}
    </Layout>
  )
}
```

* Reactはすべてのレンダリングはステートから出発するという原則があります。そのため`selectedUserId`を`useState()`で作っています。Hotwireの場合は明示的にステートを用意せず「画面に表示されているものがステートだ！」という立場を取っているので、対照的です。
* `button`タグの`onClick={() => setSelectedUserId(i + 1)}`属性により、クリックすると`selectedUserId`ステートにIntegerがセットされます
* `{ selectedUserId && <Modal id={selectedUserId} ... />}`の箇所で、[条件付きレンダー](https://ja.react.dev/learn/conditional-rendering)を使っています。`selectedUserId`がセットされていると`Modal`コンポーネントをレンダリングします
* `button`タグの`closeModal={() => setSelectedUserId(null)}`はモーダルを閉じる時の関数です。`selectedUserId`ステートを`null`にすればモーダルは閉じられます

#### モーダル表示内容の取得およびキーボードイベントの接続

**components/Modal.tsx**
```tsx
export default function Modal({closeModal, id}: {
  closeModal: () => void,
  id: number,
}) {
  const [userDetail, setuserDetail] = useState<User & UserDetail | null>(null);

  useEffect(() => {
    setuserDetail(null)
    fetch(`/api/user/${id}`).then(res => res.json())
      .then(data => {
        setuserDetail(data)
      })
  }, [id])

  useEffect(() => {
    const close = (e: KeyboardEvent) => {
      if(e.key === "Escape"){
        closeModal()
      }
    }
    window.addEventListener('keydown', close)
    return () => window.removeEventListener('keydown', close)
  }, [])

  return <>
<div>
  <div className="p-1 text-sm w-auto hover:cursor-pointer translate-x-2 active:scale-125"
       onClick={closeModal}>
    ...
  </div>
</div>
<div className="mt-5 sm:mt-6">
  {
    !userDetail
      ? <div>
        <Image src={rocketImage} alt="loader" className="m-auto mt-10 w-16 h-16"/>
      </div>
      : <div>
        ...[モーダルの内容]...
      </div>
  }
</div>
  </>
}
```

* `Modal`コンポーネントには`useEffect`が2つあります
    * １つは`id`が変更されたときにサーバにリクエストを投げて、`userDetail`取得しています。これはモーダルの内容を表示するために使用されます
    * もう１つの`useEffect`はEscapeキーでモーダルが閉じられるように、`keydown`イベントハンドラーを`window`に接続するものです
* `userDetail`がまだロードされていない時は、条件付きレンダーでローディング画面を表示します

### まとめ ===summary-react-useeffect===

* [useEffectのデモ](/modal)でもご覧いただけるように、すぐにフィードバックがある良好なUI/UXが実現できています。コードも少なく、流れが直感的にわかります。Escapeでモーダルを閉じることも比較的簡単で、Stimulusを使用した場合と同様です
* Reactではイベントハンドラから直接DOMを操作しません。イベントハンドラは先に先にステートを変更し、ステートの変更がDOMに自然に伝搬するという原則があります。この考え方をStimulusに適応することもありますが(例えば[Change Callback](https://stimulus.hotwired.dev/reference/values#change-callbacks)を使用します)、Stimulusは通常はイベントハンドラから直接DOMを操作します（CSSクラスの変更が主）。この考え方に慣れる必要があるかもしれません
* モーダルが開いた状態でブラウザをリロードすると、モーダルが閉じます。モーダルの内容をリンクすることができず、モーダルの内容を検索エンジンにインデックスさせることができません。

## React: Client Componentsでモーダルを出す方法 ===react-client-components===

ReactではRSC(React Server Components)が話題になっていますので、Client Componentを使ってモーダルを作りました。[こちらにClient Componentのデモ](/modal_app_client)を用意しています。[コードはGitHub](https://github.com/naofumi/hotwire_and_next/tree/main/app/modal_app_client)にあります。

結論から言うと、[useEffectでモーダルを出す場合](/commentaries/modal_dialogs#react-useeffect)と書き方もUI/UXもほとんど差がありません。何か固有の書き方を見逃しているかもしれませんが、確認した限りではClient Componentの書き方はPages routerで`useEffect`を使った場合と同じになります。

（`useEffect`の場合とほぼ同じため、ここでは解説を省きました）

## React: Server Componentsでモーダルを出す簡易法 ===react-server-components===

モーダルはインタラクティブな要素ですので、上記のようにClient Componentで作るのが王道に思えます。公式ドキュメントでもClient Componentのメリットを下記のように紹介しています。

> **Interactivity:** Client Components can use state, effects, and event listeners, meaning they can provide immediate feedback to the user and update the UI.

一方で[Parallel RoutesとIntercepting Routesを使って、Server Componentでモーダルを実現](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#modals)する例が公式ドキュメントで紹介されています。

そこで、ここでは**実際にServer Componentでモーダルを作って見ながら、そのUI/UXやコードの書き味を確認したいと思います**。ただしIntercepting routesとParallel routesを一度にやるのは流石に複雑なので、最初に[簡易法](#react-server-components)を紹介し、次に[Layoutを使った方法](https://nextjs.org/docs/app/building-your-application/routing/layouts-and-templates#layouts)を紹介します。Intercepting routesとParallel routesはさらにこの２つの先にある手法だと思っていて、いきなりは紹介できないと思ったからです。なお最初に示す[簡易法は私のここのブログ記事で知りました](https://medium.com/@dtulpa16/next-js-modals-made-easy-7bdce15b2a5e)。

### コード ===code-simple-react-server-components===

#### モーダルの表示

**app/modal_app/page.tsx**
```tsx
async function getUsers(): Promise<User[]> {
  console.log("Fetch start for Users")
  const res = await fetch(process.env.URL + "/api/users")
  const users = await res.json()
  return users
}

export default async function ModalAppPage({searchParams}: { searchParams: { userId: string | undefined } }) {
  const userId = searchParams.userId
  const users = await getUsers()

  return (
    <>
      ...[ページのコンテンツはここ]...
      <Link href={`/modal_app?userId=${user.id}`}
            className="underline text-orange-600 inline-block active:scale-105"
            scroll={false}>
        {user.name}
      </Link>
      ...[ページのコンテンツはここ]...
      {userId && <Modal userId={userId}/>}
    </>
  )
}
```

仕組みとしては下記のような簡単なものです。

* `/modal_app`でこのページにアクセスした場合はモーダルが表示されない
* `/modal_app?userId=1`でこのページにアクセスした場合は、userId=1のUserの情報がモーダルに表示される

これを実装するために以下のロジックになっています。
* `Link`タグのところをクリックすると、`/modal_app?userId=1`などに遷移します
* `userId = searchParams.userId`のところで、URLの`?userId=1`の箇所を読み取り、`userId`変数に格納します
* 最後の`{userId && <Modal userId={userId}/>}`で条件付きレンダーをして、`userId`がセットされている場合は`Modal`コンポーネントを表示します

なお`Link`タグには`scroll={false}`がありますので、リンク先に遷移する場合でもスクロール位置が変わらず、元の画面のステートが保たれます。

このように、**「モーダルだけ」を表示するように見せかけているが、実際にはページ全体が再表示されています**。でもネットワークが速い場合はこれでもUI/UXとしては十分で、全く気になりません。

#### モーダルのクローズ

**app/modal_app/components/Modal.tsx**
```tsx
export default async function Modal({userId}: { userId: string }) {
  const userDetail = await getUserDetails(userId);

  return (
    ...[モーダルの内容]...
      <Link className="p-1 text-sm w-auto hover:cursor-pointer translate-x-2 active:scale-125"
            href={`/modal_app`}
            scroll={false}
            prefetch={true} >
        ...[ボタンのイメージ]...
      </Link>
    ...[モーダルの内容]...
  )
}
```

* せっかくモーダルを表示するところまではServer Componentだけで来ましたので、モーダルを閉じるところもServer Componentで実装しています
* Server Componentでは、インタラクティブ要素は`a`タグと`form`タグしか使えません。ここでは`a`タグを`/modal_app`に向けました。`/modal_app`は**1.** で示した通り、モーダルを表示しませんので、**実際には画面全体が再表示されているのですが、見かけ上はモーダルだけが消えたように映ります**
* 仕組みとしては、一番最初に紹介した[カスタムJavaScriptなしの例](#turbo-without-custom-javascript)と非常によく似ています

なおNext.jsで紹介しているモーダルの例では[`router.back()`によってモーダルを閉じています](https://github.com/vercel/nextgram/blob/06a115d2cad2991b9f8163044e58f34309fea29c/app/%40modal/(.)photos/%5Bid%5D/modal.tsx#L17)ので、実質的には同じことを行なっています。ただし`router.back()`を使用するには`"use client"`を使ってModalをClient Componentにする必要があります。それもあって、ブラウザのJavaScriptをオフにして[Next.jsのデモを実行](https://nextgram.vercel.app/)するとモーダルになりません。

### UI/UX ===ui-simple-react-server-components===

[Server Componentsでモーダルを出す簡易法のデモはこちら](http://localhost:3000/modal_app)で、[コードはGitHub](https://github.com/naofumi/hotwire_and_next/tree/main/app/modal_app)にあります。

* サーバのレスポンスタイムが300ms程度であれば、快適なUI/UXになります。これは[Turbo Frames: カスタムJavaScriptなしの例](#turbo-without-custom-javascript)の例と同じです
* ただしレスポンスタイムを2000msに設定するともたつきを感じます。モーダルを表示する時も、そしてモーダルを閉じる時もフィードバックがなく、ユーザは不安を感じてしまいます。これもTurbo Frames: カスタムJavaScriptなしの例と同じです。

### まとめ ===summary-simple-react-server-components===

* コードは非常にシンプルです。これ以上シンプルにはできないぐらいにシンプルです
* サーバのレスポンスタイムが早ければ、この簡易法でも十分快適なUIを提供してくれます
* しかしサーバのレスポンスが遅い可能性がある場合は、Server Componentにこだわらず、Client Componentを使ってカスタムのイベントハンドラを書いた方が良いでしょう。これは[Turbo FramesでもカスタムJavaScriptを書くべきだ](/commentaries/modal_dialogs#summary-inline-javascript)という話と全く同じです。
* モーダルが開いた状態でブラウザをリロードしても、モーダルが開いた状態のままになります。モーダルの内容をリンクで共有でき、SEOも有利です。

## React: Server Components /w Parallel Routes ===react-server-components-with-parallel-routes===

Server Componentを使ったもう１つの方法を紹介します。[Parallel Routes](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes)を使用します。

私が理解している限りでは、元々のReactはページ全体をレンダリングすることを想定していました。ただのテキストであるHTMLと異なり、Turbo FramesやTurbo Streamsのように単純に分割したり貼り付けたりすることが得意ではありません。そこでNext.jsがApp Router導入したのが[Layout](https://nextjs.org/docs/app/building-your-application/routing/layouts-and-templates)や[Parallel routes](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes)です。

そして[Parallel Routesを使ったモーダルの作り方が公式ドキュメントで紹介されています](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#modals)。ここではそのやり方を紹介します。

### コード ===code-react-server-components-with-parallel-routes===

[コードはGitHubに掲載](https://github.com/naofumi/hotwire_and_next/tree/main/app/modal_app_parallel)しています。また[デモはこちら](/modal_app_parallel)でご確認いただけます。

パーツが多いので、概要だけ示します

1. [`layout.tsx`](https://github.com/naofumi/hotwire_and_next/blob/main/app/modal_app_parallel/layout.tsx): 部分置換をしても変わらない部分は`layout.tsx`に配置します。今回のケースではUserのリスト(`UserList`コンポーネントとして分割)は`layout.tsx`に配置します。また`layout.tsx`にはモーダルを表示するための「窓」を`{modal}`として用意しています。これは`@modal`フォルダの中を参照するようにNext.jsで自動的に関連づけられています
2. [`@modal/page.tsx`](https://github.com/naofumi/hotwire_and_next/blob/main/app/modal_app_parallel/@modal/page.tsx): ブラウザが`/modal_app_parallel`にアクセスした時、上記の`layout.tsx`の`{modal}`に差し込まれるのが`@modal/page.tsx`です。モーダルは表示しませんので、何も表示しません。そこで`null`を返します
3. [`@modal/users/[userId]/page.tsx`](https://github.com/naofumi/hotwire_and_next/blob/main/app/modal_app_layout/@modal/users/%5BuserId%5D/page.tsx): ブラウザが`/modal_app_parallel/users/1`にアクセスした時、上記の`layout.tsx`の`{modal}`に差し込まれる内容です。`[userId]`の内容を読みとり、モーダルの枠およびUserのデータを返します
4. [`@modal/loading.tsx`](https://github.com/naofumi/hotwire_and_next/blob/main/app/modal_app_layout/@modal/loading.tsx): ブラウザが`/modal_app_layout/users/1`にリクエストを投げ、レスポンスを待っている間に`layout.tsx`の`{map}`に差し込まれる内容です。モーダルの枠およびローディングアニメーションを含んでいます。

コードの詳細の解説は今回は省略させていたきますが、難しいのは各ファイル・フォルダの役割と配置です。他の実装方法と比較するとかなり複雑で、かなり慣れが必要です。

### UI/UX ===ui-react-server-components-with-parallel-routes===

* サーバのレスポンスが速い場合は、簡易法と同様の快適なUI/UXが実現できています
* サーバのレスポンスが遅くても、モーダルを表示させる際はすぐにローディングアニメーションが表示され、フィードバックが得られます。十分なUI/UXが提供できています
* モーダルを閉じる場合はモーダルを表示したまま、すぐに中でローディングアニメーションが表示されます。UI/UX的にはそれほど悪くはありませんが、理想的にはモーダルもすぐに閉じてほしいところです
* モーダルが開いた状態でブラウザをリロードしても、モーダルが開いた状態のままになります。モーダルの内容をリンクで共有でき、SEOも有利です。

### まとめ ===summary-react-server-components-with-parallel-routes===

* 必要なファイル・フォルダの役割を理解するのが大変です。少なくとも私は複雑で直感的ではないと感じました。他の方法と比べると複雑だと言えます
* 簡易法と比べて、モーダルを表示する時のUI/UXが改善されています
* サーバのレスポンスが遅いケースでモーダルを閉じる際のUI/UXは最適ではありません

コードが複雑なのがこのアプローチの欠点だと思います。

## 各技術のまとめ ===summary===

今回は大きく分けて６通り、細かく分けると８通りのモーダルダイアログの出し方を検討しました。これでも全然網羅的ではなく、他の方法もきっとあるはずです。その中で以下のことが言えるのではないかと思います。

* Turbo Framesを使用する場合、JavaScriptなしで非常に簡単に実装することができます。しかし、もう少しだけ頑張ってカスタムJavaScriptおよびCSSを書けば、使い回し可能でUI/UXが優れたモーダルダイアログが作れます。なるべくならば少し手間をかけてここまでやっていただければと思います
* Turbo FramesでStimulusを使用すると、少ないコードで優れたUI/UXが実現でき、メンテナンス性も良好です
* Reactを使う場合は、`useEffect`などを使い、ブラウザでデータをフェッチし、かつJavaScriptでDOMを操作するのが良さそうです。これはPages RouterでもApp Router (Client Component)でも変わりません。コードも簡単でわかりやすく、UI/UXも優れています
* React Server Componentsを使ったモーダルの作り方がNext.jsの公式サイトに紹介されています。しかしコードのわかりやすさとUI/UXを総合的に加味すると、私としては現時点でお勧めできません。SEOでモーダルの中身も検索エンジンにインデックスしてもらいたい場合は必要性がありますが、一般的なケースではメリットを感じませんでした。


export default function ModalDialogs({children}) {
  return <CommentaryLayout
    title="Modal Dialogs"
    subtitle="モーダル"
    section="Commentary">
    <MDXRenderer>{children}</MDXRenderer>
  </CommentaryLayout>
}
