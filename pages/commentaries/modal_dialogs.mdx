import MDXRenderer from "../../components/MDXRenderer";
import CommentaryLayout from "../../components/CommentaryLayout";
import H2WithHash from "../../components/H2WithHash";
import Image from "next/image";

モーダルダイアログはUI要素としてウェブデザインで非常によく使われます。したがって開発者としては**簡単にモーダルダイアログが作れることが重要**です。

またモーダルに表示する内容は、サーバから動的に取得することもよくあります。この場合はモーダルの表示・非表示だけでなく、サーバにリクエストを投げてレスポンスを表示することも必要になります。これをすべて、裏の画面のステート(スクロール位置など)を維持しながら行う必要があります。**ネットワーク由来の遅延対策も必要であり、ちゃんとやろうとすると意外と大変です**。

下記ではUXおよび実装の簡単さを重視しつつ、モーダルダイアログの作り方を複数検討します。Hotwireに加え、**Next.jsのApp RouterとPages Routerについてもモーダルの出し方を検討し**、比較します。

1. [Turbo Frames: カスタムJavaScriptなしでモーダルを出す方法](#turbo-without-custom-javascript)
2. Turbo Frames: カスタムJavaScriptを追加してモーダルのUI/UXを改善する方法
    1. [JavaScriptをインラインで書いた場合](#turbo-with-custom-javascript)
    2. [CSSでローディングアニメーションを追加した場合](#turbo-css-loader)
    3. Stimulusでイベント処理を改善した場合
3. [React: useEffectでモーダルを出す方法](/commentaries/modal_dialogs#react-useeffect)
4. [React: Client Componentsでモーダルを出す方法](/commentaries/modal_dialogs#react-client-components)
5. [React: Server Componentsでモーダルを出す方法](/commentaries/modal_dialogs#react-server-components)
5. [React: Server ComponentsとLayoutでモーダルを出す方法](/commentaries/modal_dialogs#react-server-components-with-layouts)

<H2WithHash id="turbo-without-custom-javascript">Turbo Frames: カスタムJavaScriptなし</H2WithHash>

まずはHotwire/Turbo Framesを使って、カスタムのJavaScriptを書かずにモーダルを出す方法を紹介します。

サーバから動的な内容をモーダルを表示する際は、通常は２つステップが必要です。

1. モーダルを表示する (カスタムJavaScriptで行う: HotwireならStimulus)
2. モーダルのコンテンツをサーバにリクエストし、結果をモーダル内に表示する (AJAX/fetchで行う: HotwireならTurbo Frames)

しかし、サーバからの**レスポンスと一緒にモーダルの「枠」も送り返せば**、モーダルを開くJavaScriptが必要なステップ1.は省略可能になります。これがこの方法の特徴です。

### コード

必要なコードは以下のものになります。ただしコントローラアクションは一般的なものなので、省略します(`pages/api/hotwire/modal_no_js`)。

**1. モーダルの「枠」とコンテンツのHTMLページ: `templates/modal_no_js/modal.ejs`**

```html
<turbo-frame id="modal">
   ...[モーダルのコンテンツ]...
</turbo-frame>
```

サーバから送り込むコンテンツのHTMLページです。今回は`turbo-frame`の中身しかありませんが、周りに関係のないHTMLがあったとしても<sup>※</sup>、`turbo-frame`の中身だけが切り抜かれて差し込まれます。そのためにコンテンツを`turbo-frame`で囲む必要があります。

<p className="text-gray-500 text-sm leading-5">※) 全画面ロードの時にも、またHTML部分置換の時にも、双方とも全く同じ１つのHTMLファイルが使えるようにTurbo Framesは設計されています。通常のTurbo Drive的なナビゲーションの時には`body`タグの中身をすべて使用してページを表示し、Ajax/fetch的なナビゲーションの時には`turbo-frame`のところだけで部分置換をするというやり方です。この中で`turbo-frame`を記述するのは冗長な気もしますが、全く同じHTMLページでも、リクエストに応じて２通りの使い方をするために必要なのです。</p>

**2. モーダル表示のトリガー: `templates/modal_no_js/index.ejs`**

```html
<a href="/api/hotwire/modal_no_js/modal?id=<%= user.id %>"
   data-turbo-frame="modal"
   class="text-orange-600 underline inline-block active:scale-105"><%= user.name %></a>
```

ユーザがこの`a`タグをクリックすると、モーダルが表示されます。`href`にはモーダルの中身のエンドポイントを指定します。1.に示したコンテンツのHTMLページです。

`data-turbo-frame="modal"`は、「サーバから送られてきたHTMLを`id="modal"`の`turbo-frame`に差し込んでください」という指示になります。

**3. モーダルHTML断片の差し込み先: `templates/modal_no_js/index.ejs`**

```html
<turbo-frame id="modal"></turbo-frame>
```

サーバから送られてきたHTMLはここに差し込まれます。

**4. モーダルを閉じるボタン: `templates/modal_no_js/modal.ejs`**

```html
<a class="p-1 text-sm w-auto hover:cursor-pointer translate-x-2 active:scale-125"
     href="/api/hotwire/modal_no_js">
```
カスタムJavaScriptを使用しませんので、ブラウザの操作は`a`タグや`form`タグに限定されます。ここでは`a`タグを使用して、モーダル表示前のページをリクエストしています。

ブラウザが受け取るHTMLレスポンスには空の`turbo-frame`が含まれています。そこで既存の`turbo-frame`をこの空の`turbo-frame`に入れ替えて、その結果、モーダルが閉じます。ブラウザが受け取るHTMLは`turbo-frame`だけではなく、`templates/modal_no_js/index.ejs`のすべてです。しかし画面に反映されるのは`turbo-frames`の中身(空)であることに注意してください。

### UI/UX

[カスタムJavaScriptなしで作ったデモ](/api/hotwire/modal_no_js)を用意していますので、ご覧ください。[トップページ](/)からで遅延を設定できますので、300msの場合と2000msの場合を比較してください。

* サーバのレスポンスが十分に速い場合(300msの場合)は快適です。
* しかし遅延を2000msに設定するとUI/UXの弱点が見えてきます。リンクを押してもフィードバックがなく、ユーザはシステムが正しく動作している自信が持てません。またモーダルを閉じる時も遅延が発生します。「閉じるだけなら瞬間的に行くのでは？」というユーザ期待と反して、サーバからレスポンスが帰ってくるまでモーダルは閉じません。<br />(リンク等をクリックした時にCSS `:active`を使っていますが、十分なフィードバックとは言えません)

カスタムJavaScriptなしの場合はコードが非常に簡素で、直感的にもわかりやすいものになります。しかし、特にネットワークが遅い場合は、ユーザの操作に対するフィードバックが弱く、良いUI/UXとは言えません。



<H2WithHash id="turbo-with-custom-javascript">Turbo Frames: Inline JavaScript</H2WithHash>

上記の[Turbo Frames: カスタムJavaScriptなし](http://localhost:3000/commentaries/modal_dialogs#turbo-without-custom-javascript)の問題点を解消し、ネットワークが遅い場合でも十分なUI/UXを提供するためにカスタムJavaScriptを書きます。上記ではモーダルの「枠」をサーバから送ることでモーダルを開くステップを省略していました。しかしここではちゃんとJavaScriptを使って、**サーバレスポンスの遅延の有無に関わらず、リクエストを投げた瞬間にモーダルを開きます**。これがユーザに対するフィードバックとなり、UI/UXの改善に繋がります。

なおHotwireでカスタムJavaScriptを書く場合は、一般には[Stimulus](https://stimulus.hotwired.dev)を使います。これは非常に便利ですが、最初はとっつきにくいので、インラインJavaScriptを使った例から紹介します。

### コード

JavaScriptなしの場合と比較して、以下のコードが追加されます。

1. モーダルの「枠」のHTMLをあらかじめ元のページに挿入しておきます。ただし`display:none`で隠して見えなくします。この中にHTML断片を差し込む目印の`turbo-frame`を入れておきます
2. モーダルの表示をトリガーするJavaScriptの設置。Turboがサーバにリクエストを投げるのは前回と変わらないのですが、これとは独立にモーダルを表示するJavaScriptを用意します。リンクをクリックしたときに、この２つが同時に実行されます。
3. モーダルを閉じるボタンがJavaScriptを呼び、モーダルだけが閉じるようにします。

**1. モーダルの「枠」と内容を含むHTMLページ: `templates/modal_w_js/modal.ejs`**

```html
<turbo-frame id="modal">
   ...[モーダルのコンテンツ]...
</turbo-frame>
```

JavaScriptなしの場合と比べると、モーダルの「枠」をここに書いていないのが特徴です。モーダルの中身だけを置いておきます。


**2. モーダル表示のJavaScript: `templates/modal_w_js/index.ejs`**

```html
<script>
  function openModal() {
    const turboFrame = document.querySelector("turbo-frame#modal")
    turboFrame.innerHTML = '<div class="!min-w-96 text-center relative transform overflow-hidden rounded-lg bg-white px-4 pb-4 pt-5 text-left shadow-xl transition-all sm:my-8 sm:w-full sm:max-w-sm sm:p-6">Loading... </div>'
    const modal = document.querySelector(".modal-dialog")
    modal.classList.add("modal-open")
  }

  function closeModal() {
    const modal = document.querySelector(".modal-dialog")
    modal.classList.remove("modal-open")
  }
</script>
```

モーダルの表示・非表示を制御するJavaScriptを、`script`タグで囲んでインラインで書いています。内容は単にモーダルの「枠」に`.modal-open`のCSSクラスをつけたり外したりするだけです。さらに`openModal()`では、`turbo-frame`の"Loading..."と表示させ、ローディング中の表示をさせています。


**3. モーダル表示のトリガー: `templates/modal_w_js/index.ejs`**

```html
<a href="/api/hotwire/modal_w_js/modal?id=<%= user.id %>"
   data-turbo-frame="modal"
   onclick="openModal()"
   class="text-orange-600 underline inline-block active:scale-105">
  <%= user.name %>
</a>(Inline JS)<br>
```

"Inline JS"と書いてある方の`a`タグに着目します。まず`onclick`属性で`openModal()`を呼び出して、モーダルを表示させています。さらに`data-turbo-frame="modal"`属性がありますので、`href`で指定したエンドポイントから得られたHTMLを`turbo-frame id="modal"`に差し込むという指示になります(上記と同じ)。

`a`タグにこの２つの属性をつけることにより、モーダルを表示させるコードとTurbo Frameにデータを読み込むコードを分けることができました。そのため、サーバからのレスポンスが遅延しても、まず先にモーダルを表示させることができます。"Loading..."を表示させるようにしたもの、空白のモーダルでは味気ないからです。

「モーダルの開閉」「サーバからのデータの読み込み」を独立させたことがポイントと言えます。

**4. モーダルを閉じるボタン: `templates/modal_w_js/modal.ejs`**

```html
<button class="p-1 text-sm w-auto hover:cursor-pointer translate-x-2 active:scale-125"
        onclick="closeModal()">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"
       class="mx-auto size-6 text-orange-600">
    ...
  </svg>(Inline JS)
</button>
```

モーダルを閉じる`button`タグでは、`onclick="closeModal()"`としています。先ほど用意した`closeModal()`を呼び出して、モーダルを閉じています。[カスタムJavaScriptを使わない例](/commentaries/modal_dialogs#turbo-without-custom-javascript)と異なり、モーダルの開閉とサーバからのデータの読み込みが分かれていますので、モーダルだけ瞬時に閉じることができています。

### UI/UX

[JavaScriptを使った例のデモを用意しています](/api/hotwire/modal_w_js)ので、お試しください。他の例も同じデモ画面に含めていますので、"Inline Javascript"のUI/UXを確認する場合は、"Inline JS"と書いてあるボタンを押してください。

* モーダルダイアログは瞬時に表示されます
* サーバのレスポンスが遅い場合は"Loading..."と表示されますので、リクエストが送信され、サーバのレスポンス待ちであることがわかります。ユーザへのフィードバックが適切にされていますので、UI/UXは良くなっています。
* クローズボタンを押したときにモーダルダイアログは瞬時に閉じます。これはユーザの期待に沿いますので、UI/UXは良くなっています。

### まとめ

* カスタムJavaScriptなしの例に比べて多少はコードが増えていますが、10行程度です
* モーダル「枠」はサーバから送信されるのではなく、元のページに含まれています

Turbo Framesを使うと[カスタムJavaScriptなし](commentaries/modal_dialogs#turbo-without-custom-javascript)でもモーダルが作れます。宣伝文句としてはインパクトがあるせいか、このやり方を非常に多く見かけるように思います。しかしHotwireがStimulusとセットになっていることからも分かるように、**HotwireはむしろカスタムJavaScriptを書くことを奨励しています**。そしてここで確認したように、わずか10行程度のJavaScriptでUI/UXを大きく改善できています。

ぜひ「JavaScriptなし」の宣伝文句に踊らされず、UI/UXを改善する簡単なJavaScriptを使うようにしていただければと思います。



<H2WithHash id="turbo-css-loader">Turbo Frames: CSSローディングアニメーション</H2WithHash>

[Inline JavaScript](#turbo-with-custom-javascript)の項では、カスタムJavaScriptを使ったおかげでモーダルが瞬時に表示されるようになりました。つまりサーバからのレスポンスよりも前にモーダルが表示されます。そのため、なんらかのローディングアニメーションが必要になります。

前の項では単純に"Loading..."の文字列をJavaScriptで差し込みました。これでも良いのですが、Turboはロード中に`busy`のHTML属性を自動的に付けてくれますので、CSSだけでもローディングアニメーションを表示できます。ここではこの方法を紹介します。


















**2. モーダル表示のJavaScript: `public/hotwire/javascript/labeler_controller.js`**

```js
  add() {
    const labelable = document.querySelector(this.selectorValue)
    labelable.classList.add(this.labelClass)
  }

  remove() {
    const labelable = document.querySelector(this.selectorValue)
    labelable.classList.remove(this.labelClass)
  }
```

モーダルの開閉は、モーダル「枠」の表示・非表示の切り替え操作だけになります。

今回は`labeler_controller.js`をStimulusで作成し、トリガーを押した時に切り替えられるようにしています。`this.selectorValue`はモーダル「枠」をDOMから選択するためのCSSセレクター、`this.labelClass`は表示・非表示の切り替えに使用するCSSクラスで、別途HTMLの中に記述しておきます。こうすることで、`labeler_controller.js`が使いまわせるようにしています。

`add()`はモーダルを開き、`remove()`はモーダルを閉じます。

**3. モーダル表示のトリガー: `templates/modal_w_js/index.ejs`**

```html
<div class="inline-block min-w-full py-2 align-middle sm:px-6 lg:px-8"
     data-controller="labeler"
     data-labeler-selector-value=".modal-dialog"
     data-labeler-label-class="modal-open"
>
  ...
  <a href="/api/hotwire/modal_w_js/modal?id=<%= user.id %>"
     ...
     data-action="click->labeler#add"
     class="text-orange-600 underline inline-block active:scale-105">
    <%= user.name %>
  </a>
  ...
</div>
```

JavaScriptなしの場合と同様に、`a`タグをクリックすることでモーダルが開くようにしています。`a`タグには多数の属性が付いていますが、これはどのモーダルにどのようなCSSクラスを付与し、開閉をするかの指示になります。

1. `data-controller="labeler"`は、この`div`タグに囲まれている部分を`javascript/labeler_controller.js`に繋げるためのものです。この中を`javascript/labeler_controller.js`に制御させているイメージになります。
2. `data-labeler-selector-value=".modal-dialog"`、`data-labeler-label-class="modal-open"`は`javascript/labeler_controller.js`の動きをカスタマイズするための引数です。どのモーダル「枠」を制御するか、および開閉指示に使用するCSSクラスを指定しています。
3. `data-action="click->modal#open"`は、このリンクがクリックされた時に`javascript/labeler_controller.js`の`add()`メソッドを呼び出すように指示します。

少しくどい記述ですが、`javascript/labeler_controller.js`の使い回しが効くようにするため、変更できるパラメータが多くなっているためです。

Reactでは、コンポーネントの中に、表示用HTMLとイベント処理JavaScriptを合わせて持たせています。同じロジックを複数のコンポーネントで繰り返し使っている場合は、カスタムフックなどを作ってDRYにします。

Stimulusの場合は表示用HTMLとイベント処理用JavaScriptを別のファイルに持ちます。そしてHTMLに`data-controller`などの属性を書くことで繋げます。Stimulus controllerはReactのカスタムフックに対応し、同じような役割を担っています。この辺りはまた別の機会に紹介したいと思います。

なお、Stimulus controllerを使うのが面倒であれば、下記のように直接書き込んでも構いません。ただしキーボードイベントなど、より複雑なイベントを処理する可能性がある場合、さらにコードの再利用性を高めたい場合は、やはりStimulusがおすすめです。

**`templates/modal_w_js/index.ejs`**
```html
<div class="inline-block min-w-full py-2 align-middle sm:px-6 lg:px-8"
>
  ...
  <a href="/api/hotwire/modal_w_js/modal?id=<%= user.id %>"
     ...
     onclick="openModal"
     class="text-orange-600 underline inline-block active:scale-105">
    <%= user.name %>
  </a>
  ...
  <script>
    function openModal() {
      document.querySelector(".modal-dialog")
              ?.classList.add("modal-open")
    }
  </script>
</div>

```

**4. Turbo Framesを使ったサーバリクエスト**

`templates/modal_w_js/index.ejs`の、先ほどモーダル表示のトリガーを追加した`a`タグに`data-turbo-frame`タグを追加します。

```html
<a href="/api/hotwire/modal_w_js/modal?id=<%= user.id %>"
   data-turbo-frame="modal"
   data-action="click->labeler#add"
   class="text-orange-600 underline inline-block active:scale-105">
  <%= user.name %>
</a>
```

このすると、`a`タグをクリックした時にモーダルが開くと同時に、`/api/hotwire/modal_w_js/modal?id=[...]`のエンドポイントにリクエストが投げられます。そしてレスポンスの`turbo-frame`の内容が、`id="modal"`の`turbo-frame`に差し込まれます。(1.で作成したモーダル「枠」の中)

**5. モーダルを閉じるボタン: `templates/modal_w_js/modal.ejs`**

```html
  <div class="relative z-10"
       aria-labelledby="modal-title"
       role="dialog"
       aria-modal="true"
       data-controller="labeler"
       data-labeler-selector-value=".modal-dialog"
       data-labeler-label-class="modal-open"
  >
    ...
    <button class="..."
            data-action="click->labeler#remove keydown.esc@window->labeler#remove">
```

ここはモーダルのクローズボタンの制御です。先ほどの`a`タグとはDOM的に離れている箇所に配置される可能性がありますので、別途`javascript/labeler_controller.js`と繋げています。同じモーダルを操作しますので、`data-labeler-selector-value`や`data-labeler-label-class`は共通です。

クローズボタンは`button`タグのところです。`data-action`の中の`click->labeler#remove`は、クリックしたら`javascript/labeler_controller.js`の`remove()`メソッドを呼び出します。CSSクラスの`modal-open`がモーダル枠から外されるので、モーダルが閉じます。

また`esc@window->labeler#remove`はESCキーのイベント処理を記述しています。ESCキーが押されたら同様に`remove()`メソッドを呼び出す指示です。このようにStimulus controllerを書くと、イベント処理が非常に簡潔にわかりやすく記述できます。

### UI/UX


### まとめ

以上Stimulusの紹介もしたために長くなってしまいましたが、Turbo FramesにJavaScriptを追加するとUI/UXを大きく改善できることが確認できたかと思います。

* Turbo Framesにごく少量のJavaScriptを追加するとUI/UXが大きく改善します
* CSSを使うだけでローディングアニメーションが実装できます
* Stimulus controllerは多少慣れが必要ですが、使うとキーボードイベントなどのイベント処理が大きく簡素化され、かつコードの再利用性が高まります




<H2WithHash id="react-useeffect">React: useEffectでモーダルを出す方法</H2WithHash>


<H2WithHash id="react-client-components">React: Client Componentsでモーダルを出す方法</H2WithHash>


<H2WithHash id="react-server-components">React: Server Componentsでモーダルを出す簡易法</H2WithHash>


<H2WithHash id="react-server-components-with-layouts">React: Server Componentsに加えてNext.js Layoutを使いUXを改善する方法</H2WithHash>



<H2WithHash id="summary">まとめ</H2WithHash>


モーダルダイアログのUXに大きな課題が出るのは、サーバのレスポンスが遅い時です。速ければ、上記のどれを選択しても大差ありません。遅い時に違いが出ます。

サーバ・ネットワークが十分に速いのであれば(例えば一貫して300ms程度でレスポンスを返してくれる状態であれば)、React Server Componentsの簡易法、もしくはHotwireでカスタムJSを使わない方法などで十分でしょう。これより遅い場合であっても、prefetchを要所に使えば大丈夫なケースも多いです。ただし**ReactであればuseEffectやClient Componentを使った方法、HotwireであればカスタムJSを使った方法も分かりやすく、最初からこっちにしておく方が賢明に思えます**。

いずれにしても、サーバからのレスポンスが遅い場合も想定しながらUXをテストすることが重要だと思います。

Server Componentsでは簡易法の他にLayoutを使ったり、それを拡張したParallel Routesを使う方法もあり、Next.js公式ドキュメントでも紹介されています。UXも改善します。しかし実際にやってみたところ、ファイルベースルータのファイル構成が複雑になり、直感的でなくなりました。あまりお勧めしません。

<H2WithHash id="appendix">補足</H2WithHash>


今回はCSSクラスだけで開閉状態を変更できるモーダルを使用しています。Bootstrapやブラウザネイティブの`dialog`によるモーダルなどはJavaScriptで開閉を制御しますので、別途紹介したいと思います。

またモーダルの種類も用途は様々なので、今回だけではコツをすべてカバーできません。これについては追って紹介していきたいと思います。

<p className="text-gray-500 text-sm leading-5">※) モーダルダイアログは、元の画面のステートを維持しつつ、新しい画面を表示してくれるUI要素です。ステートとは`input`タグに入力されている内容、スクロール位置、アコーディオンの開閉状態などです。逆に言うとステートを維持する必要がない場合はモーダルダイアログの価値がありません。一方でステートを維持したい場合、選択肢はモーダルダイアログだけではありません。ポップアップやインラインに追加情報を記載することもできます。本当にモーダルが必要かを考えた上で、もし必要だとしても、他により良い方法がないかを検討するべきだと私は思います。例えばRuby on Railsを作った37signals社は元々ウェブデザイン会社として創業していますが、ここのSaaS製品はモーダルダイアログではなく、別の方法を使います。とはいえ、世界はモーダルで溢れています。簡単に作れるかどうかはいずれにしても重要です。</p>


export default function ModalDialogs({children}) {
  return <CommentaryLayout
    title="Modal Dialogs"
    subtitle="モーダル"
    section="Commentary">
    <MDXRenderer>{children}</MDXRenderer>
  </CommentaryLayout>
}
