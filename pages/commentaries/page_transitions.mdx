import MDXRenderer from "../../components/MDXRenderer";
import CommentaryLayout from "../../components/CommentaryLayout";
import StyledLink from "../../components/StyledLink";
import Image from "next/image"
import transitionImage from "@/public/images/transition-after-first-load.webp"
import StyledList from "../../components/StyledList";

Hotwireで一番最初に紹介する技術は[Turbo Drive](https://turbo.hotwired.dev/handbook/drive)です。Turbo Driveはリンクのクリックによるページ遷移（全画面置換）の技術で、Next.jsでいうと[Linkタグ](https://nextjs.org/docs/pages/api-reference/components/link)に相当します。

画面遷移なので、一見すると従来のMPAと変わらない動きですが、Turbo DriveもNext.jsのLinkタグも内部ではSPA的な技術を採用しており、スピード等のUI/UXが改善されています。画面数が多いウェブサイト・ウェブアプリでは、全体のUI/UXに大きなインパクトがあります。

<p className="my-2 text-sm text-gray-600">※
  Turbo DriveもLinkタグも最初にサイトを訪問した時のUI/UXではなく、サイト内のリンクをクリックしたときの動作を担います</p>


<div className="mt-8 flow-root">
  <div className="-mx-4 -my-2 overflow-x-auto sm:-mx-6 lg:-mx-8">
    <div className="inline-block min-w-full py-2 align-middle sm:px-6 lg:px-8">
      <table className="min-w-full divide-y divide-gray-300">
        <caption className="caption-top text-left font-bold">ページ遷移技術の比較</caption>
        <thead>
        <tr>
          <th scope="col" className="py-3.5 pl-4 pr-3 text-left text-sm font-semibold text-gray-900 sm:pl-3">技術</th>
          <th scope="col" className="min-w-28 px-3 py-3.5 text-left text-sm font-semibold text-gray-900">データロード</th>
          <th scope="col" className="min-w-28 px-3 py-3.5 text-left text-sm font-semibold text-gray-900">ローダー表示</th>
          <th scope="col" className="min-w-28 px-3 py-3.5 text-left text-sm font-semibold text-gray-900">prefetch</th>
          <th scope="col" className="min-w-28 px-3 py-3.5 text-left text-sm font-semibold text-gray-900">セキュリティ</th>
          <th scope="col" className="px-3 py-3.5 text-left text-sm font-semibold text-gray-900">その他</th>
        </tr>
        </thead>
        <tbody className="bg-white">
        <tr key={1} className="even:bg-gray-50">
          <td className="whitespace-nowrap py-4 pl-4 pr-3 text-sm font-medium text-gray-900 sm:pl-3">[ネイティブ(MPA)](/api/hotwire/users)</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">先にロード</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">する</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">しない</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">○</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">JavaScript, CSSは要再読み込み</td>
        </tr>
        <tr key={2} className="even:bg-gray-50">
          <td className="whitespace-nowrap py-4 pl-4 pr-3 text-sm font-medium text-gray-900 sm:pl-3">[Hotwire (Turbo Drive)](/api/hotwire/users)</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">先にロード</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500"><StyledLink
              href="https://turbo.hotwired.dev/handbook/drive#displaying-progress">する</StyledLink></td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500"><StyledLink
              href="https://turbo.hotwired.dev/handbook/drive#prefetching-links-on-hover">する</StyledLink></td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">○</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">hoverでprefetch</td>
        </tr>
        <tr key={3} className="even:bg-gray-50">
          <td className="whitespace-nowrap py-4 pl-4 pr-3 text-sm font-medium text-gray-900 sm:pl-3">[Next SSG](/users_ssg)</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">先にロード</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">要作成</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500"><StyledLink
              href="https://nextjs.org/docs/pages/api-reference/components/link#prefetch">する</StyledLink></td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">△ (要DAL)</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">動的なサイトでは使えないが、参考までに紹介</td>
        </tr>
        <tr key={4} className="even:bg-gray-50">
          <td className="whitespace-nowrap py-4 pl-4 pr-3 text-sm font-medium text-gray-900 sm:pl-3">[Next useEffect](/users)</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">後にロード</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">要作成</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500"><StyledLink
              href="https://nextjs.org/docs/pages/api-reference/components/link#prefetch">静的な部分まで</StyledLink></td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">△ (要DAL)</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">useEffect内のfetchはprefetchされない</td>
        </tr>
        <tr key={5} className="even:bg-gray-50">
          <td className="whitespace-nowrap py-4 pl-4 pr-3 text-sm font-medium text-gray-900 sm:pl-3">[Next page router SSR](/users_ssr)</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">先にロード</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">要作成</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">しない</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">△ (要DAL)</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">SSRを使うとprefetchしない</td>
        </tr>
        <tr key={6} className="even:bg-gray-50">
          <td className="whitespace-nowrap py-4 pl-4 pr-3 text-sm font-medium text-gray-900 sm:pl-3">[Next app router Server component](/users_app)</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">先にロード</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">要作成</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500"><StyledLink
              href="https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching">静的な部分まで</StyledLink></td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">△ (要DAL)</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">dynamic componentを使った場合はloading.jsのところまでprefetch</td>
        </tr>
        </tbody>
      </table>
    </div>
  </div>
</div>


## Turboの実装 ===installing-turbo===

Hotwireは[Turbo](https://turbo.hotwired.dev)/[Stimulus](https://stimulus.hotwired.dev)/[Strada](https://strada.hotwired.dev)の３つのパーツからなっています。ウェブで使用するのはTurboとStimulusですが、双方ともJavaScriptのファイルを読み込むだけで使用でき、インストールは簡単です。ここでは[Turbo Drive](https://turbo.hotwired.dev/handbook/drive)を使用しますので、TurboのJavaScriptファイルを読み込みます。

**MPAのページにTurboのJavaScriptファイルを読み込むだけで、Turbo Driveによる画面遷移が手に入ります。** インストール方法はファイルを読み込むだけです。[公式ドキュメント](https://turbo.hotwired.dev/handbook/installing)を確認してください。

本サイトではnpm等を使用せずに、コンパイル済みのJavaScriptファイルをダウンロードしてインストールしました。TurboのJavaScriptファイルは`public/hotwire/javascript/turbo.es2017-esm.js`にダウンロードされており、`templates/layouts/header.ejs`から参照されています。


**templates/layouts/header.ejs**
```html
<head>
  ...
  <script src="/hotwire/javascript/turbo.es2017-esm.js" data-turbo-track="reload" type="module"></script>
  ...
</head>
```

Turbo Driveを導入した時の効果は[デモページ](/api/hotwire/users)でご確認ください。



## ページ遷移のUX ===page-transition-ux===

本サイトでは、各技術を使った際のUXを確認していただくために、デモを用意しています。上の表の各技術名をクリックして、実際にUXをご体験ください。

### SPAの効果 ===spa-effect===

上記の表に挙げた技術は、ネイティブを除いて、全てSPA ([Single-page Application: シングルページアプリケーション](https://ja.wikipedia.org/wiki/シングルページアプリケーション))です。Next.jsの場合はSSRであっても、２つ目のページはSPA的に遷移します。

ここでいうSPA的というのは、ページ切り替え時に[AJAX](https://ja.wikipedia.org/wiki/Ajax)等を使っていて、一見するとページ全体は切り替わっているものの、裏でロードされたJavaScriptやCSSはそのまま残しているという意味です。先のページをメモリに残しつつ画面遷移するため、よりスムーズなページ切り替えが可能になり、またキャッシュなどのパフォーマンス最適化がしやすくなっています。

ただし最近の高性能マシンではJavaScriptやCSSを読み込まないことによる効果はわずかであり、ほとんど感じることができません。実際[Astro](https://astro.build)などのフレームワークはSSRをするものの、２ページ目のSPA的遷移は省略しています。

SPA的な画面遷移の効果を強く感じさせてくれるのは、次に紹介するprefetchと組み合わせた時です。

### Prefetchの効果 ===prefetch-effect===

[Turbo Driveをインストール](#installing-turbo)するだけで、ページ遷移はヌルサクになります。ネイティブな画面遷移とTurbo Driveによる[画面遷移を比べていただくと](/api/hotwire/users)一目瞭然です。

この効果のほとんどは[prefetch](https://turbo.hotwired.dev/handbook/drive#prefetching-links-on-hover)によるものです。マウスカーソルがリンクの上をホバーした時に、**フライング**をしてサーバにリクエストを飛ばします。そして実際にユーザがリンクをクリックしたとき、すでにリンク先ページは読み込まれていますので、瞬間的に画面遷移ができます。

### Next.jsのprefetchは条件によっては動かない ===next-prefetch-only-works-sometimes===

Next.jsにもprefetchがあります。しかし多くのケースでは効果がありません。Pages routerの場合、SSRのページではprefetchは効果がありません。またApp routerで[Dynamic rendering](https://nextjs.org/docs/app/building-your-application/rendering/server-components#dynamic-rendering)の場合は最初の`loading.js`ファイルまでしかprefetchしませんので、[prefetchはローディング画面の表示を早めてくれるだけ](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)の効果しかありません。逆に言うと、**Next.jsの場合、Pages routerのSSGやApp routerのStatic renderingの場合に限ってならprefetchが有効になります**。

本サイトの例を見ても、[Next SSGの場合](/users_ssg)はヌルサクな画面遷移をしますが、[Next useEffect](/users)、[Next app router](/users_app)の場合はまずはローダー画面だけがすぐに表示され、後になってちゃんとデータのある画面が現れます。そして[Next SSR](/users_ssr)の場合はクリック直後はページが変わらず、データのある画面が現れるのが遅れます。

このようにNext.jsはprefetch機能はありますが、機能するのは静的なページのところまでです。動的なコンテンツはprefetchされません。動的コンテンツが多いサイトの場合はNext.jsのprefetchは効果がかなり限定的です。なお本サイトは動的コンテンツのサイトを作成している開発者を念頭にした解説を行っています。そのため、App routerのキャッシュは極力オフにしており、全てのページは[Dynamic rendering](https://nextjs.org/docs/app/building-your-application/rendering/server-components#dynamic-rendering)させています。

<div className="mt-12">
  <div className="w-max-[560px] flex justify-center">
    <iframe className="aspect-video" src="https://www.youtube.com/embed/UWluEz8YPbo?si=ZPz6s2MWPQShzH6q"
            title="YouTube video player" frameBorder="0"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
            referrerPolicy="strict-origin-when-cross-origin" allowFullScreen></iframe>
  </div>
</div>
<figure className="mt-12">
  <figcaption className="font-bold">各種の技術を使用した時の画面遷移の違い</figcaption>
  <Image src={transitionImage} alt="Page Transition image"></Image>
</figure>

### キャッシュの効果 ===cache-effect===

Turbo Driveには[仕組みをほとんど理解していなくても安心して使用できるキャッシュ](https://turbo.hotwired.dev/handbook/building#understanding-caching)があります。

以前に訪問したページに遷移すると、Turbo Driveは以前のページ内容をプレビューとして表示します(キャッシュから表示)。そして同時にサーバにリクエストを投げ、サーバから最新のページを受け取ると、すぐにプレビューの内容と入れ替えます。

キャッシュの問題は古い情報が表示されたままになってしまうことですが、この仕組みのおかげでTurbo Driveはこの問題を回避しています。つまりキャッシュを利用しているおかげでユーザとしてはページ遷移が瞬間的に起こったように感じ、UI/UXが大幅に向上する一方、キャッシュの欠点がないわけです。

これは簡単なことではありません。多くの場合、キャッシュを導入すると予想しない動きが起きてしまい、うまく利用するのが困難です。最近で言えば、Next.jsでキャッシュを導入してみたものの、[評判が悪くてv15でデフォルトをキャッシュオフにした](https://nextjs.org/blog/next-15-rc#caching-updates)のは記憶に新しいところです。残念ながらNext.jsではまだ代替案が用意されておらず、キャッシュを利用できるかどうかは慎重に判断する必要があります。

## セキュリティ: データ漏洩 ===security===

ここではサーバからブラウザに機密性の高い情報が流れてしまうデータ漏洩の問題を取り上げます。上記の各方式は、サーバからブラウザにデータを渡す仕組みが異なります。ネイティブとTurbo DriveはHTMLのみを送ります。Next.js pages routerのSSRはHTMLに加え、React Hydration用のデータを送り、一方でapp routerはServer Componentの場合はHTMLに加えてRSC payloadを送ります。またuseEffectの中からfetchをする場合はJSON APIを送ります。

用いる方式の違いにより、データ漏洩のリスクおよび注意しなければならないポイントが異なります。ここでは実際のデモを見せながら、具体的に紹介します。

### HTMLだけを送る場合はリスクが少ない ===sending-html-is-secure===

ネイティブ(MPA)及ぼHotwireでは、サーバはHTML<strong>のみ</strong>をブラウザに送ります。HTMLには画面に表示される情報しかありません。そのため、意図しないデータをブラウザに送ってしまう可能性は低く、データ漏洩のリスクは少ないと言えます。

またユーザの権限によって見せるべきデータを変えなければならないときは、controllerもしくはviewテンプレートの中で出し分けることが一般的で、追加のセキュリティーレイヤーなどは不要です。

### JSONを送る場合は注意が必要 ===sending-json-requires-care===

`useEffect`を使う場合は、`useEffect`の中からサーバのJSON APIに対してデータfetchをすることが一般的です。このAPIは一般にバックエンドのエンジニアが管理し、フロントエンドと合意したAPI設計に基づいて、出すべくデータと隠しておくべきデータを明確に管理します。その結果、データ漏洩が起こりにくい体制になっています。

一方でNext.jsによるSSG/SSRページ作成は、フロントエンドに任されることが多くなります。しかし実際には、Next.jsも（見えないところで）JSON APIが作られます。`getStaticProps()`, `getServerSideProps()`の返り値がそのままJSON APIになるのです。このJSON APIは２回目以降のページ遷移の時にそのままサーバからブラウザに送られます。また初回ロードの時も、SSRのHTMLの最後に、hydration用のデータとしてブラウザに送られます。このように`getStaticProps()`, `getServerSideProps()`の返り値はそのままブラウザに送られます。

`useEffect`の時のJSON APIの時と異なり、`getStaticProps()`, `getServerSideProps()`の返り値を明確に取り決めることはないと思います。しかしここで隠すべきデータをしっかりブロックしなければ、機密データは漏洩してしまいます。

### セキュリティのデモ ===security-demo===

本デモでは、敢えてセキュリティ上問題のあるコードをバックエンドで書いています。セキュリティの問題を浮き彫りにするためです。

具体的には`User repository`がそのまま`password_digest`(秘密の情報)を返してしまうようにしています。また各エンドポイントでも`password_digest`をブロックする処理を行っていません。

* [ネイティブ画面遷移(MPA)](/api/hotwire/users)および[Turbo Drive](/api/hotwire/users)を使っている場合は`password_digest`は漏洩しません。レスポンスにはHTMLしか含まれないので、画面に表示しない内容はブラウザに送信されないためです。ブラウザの検証画面のネットワークタブを確認し、送信されてくる各ファイルの中身を見ても、`password_digest`の情報はありません。
* [Next.js useEffect](/users)の時は`/api/users`からのJSONレスポンスに`password_digest`が出てしまうように作ってありますので、ここから漏洩します。しかしこのようなAPIは注意深く設計されることがほとんどだと思いますので、問題にはなりにくいと考えられます。
* Next.js Pages
routerの[SSG](/users_ssg)および[SSR](/users_ssr)の時は、最初にダウンロードされるHTMLファイル最下部の`script`タグ中に`password_digest`が漏洩します。これはhydration用のデータであり、HTMLに`password_digest`がレンダリングされるかどうかに関わらず含まれます。またページ遷移をするたびにダウンロードされるJSONファイルにも漏洩します。
* [Next.js App routerのServer componentだけ](/users_app)を使っている場合は`password_digest`は漏洩しません。RSC
payloadはHTMLにレンダリングされる内容しか含まないためです。しかしServer componentの中にClient
componentを埋め込んでいる場合は[データが漏洩する可能性があります](https://zenn.dev/moozaru/articles/d270bbc476758e)ので、要注意です。


Next.jsをセキュアにする場合は`User repository`のデータをそのままコンポーネントに渡さず、[Data Access
Layer](https://nextjs.org/blog/security-nextjs-server-components-actions#data-access-layer)を作り、この中で権限に応じて必要なデータのみを含むDTO(Data
Transfer Object)を作成することが公式ページで奨励されています。
Reactの方でも[React
Taint API](https://nextjs.org/docs/app/building-your-application/data-fetching/patterns#preventing-sensitive-data-from-being-exposed-to-the-client)で対策されていく見込みですが、ただしこれはどちらかというと注意喚起のメカニズムだけであり、対応は別途必要になりそうです。

一方でHotwireの場合は、HTMLを出力するテンプレートファイル自身がこのようなData Access Layerの役割を果たしているとも言えます。実際、権限チェックなどはview Templateの中でやることが多いです。不要な情報が漏れ出ている場合は画面でもすぐに確認できますので、安全性が高いと言えます。

結論としてMPAやTurbo Driveを使用するときに比べ、Next.jsはデータ漏洩に神経を使う必要がありそうです。

<div className="mt-12">
  <div className="w-max-[560px] flex justify-center">
    <iframe className="aspect-video" src="https://www.youtube.com/embed/LxLhCviX8iQ?si=wjTL03S_bw7k25OF"
            title="YouTube video player" frameBorder="0"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
            referrerPolicy="strict-origin-when-cross-origin" allowFullScreen></iframe>
  </div>
</div>



export default function ({children}) {
  return <CommentaryLayout
    title="Page Transitions"
    subtitle="ページ遷移"
    section="Commentary">
    <MDXRenderer>{children}</MDXRenderer>
  </CommentaryLayout>
}
