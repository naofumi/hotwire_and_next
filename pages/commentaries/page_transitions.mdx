import MDXRenderer from "../../components/MDXRenderer";
import CommentaryLayout from "../../components/CommentaryLayout";
import StyledLink from "../../components/StyledLink";
import H2WithHash from "../../components/H2WithHash";
import Image from "next/image"
import transitionImage from "@/public/images/transition-after-first-load.png"
import StyledList from "../../components/StyledList";

Hotwireで一番最初に紹介する技術は[Turbo Drive](https://turbo.hotwired.dev/handbook/drive)です。Turbo Driveはページ遷移のUXを大幅に向上させます。

ウェブの根幹をなすのはリンクです。ウェブの最も基本的でかつ重要な動作は、リンクをクリックした後のページの遷移です。それだけにUXへのインパクトが大きいものです。

[Turbo Drive](https://turbo.hotwired.dev/handbook/drive)は大幅にUXを向上させるだけでなく、サーバからJSON APIを送信する際のセキュリティの心配も不要です。Next.jsよりも気楽に使え、かつ良いUXになりやすいです。

<p className="my-2 text-sm text-gray-600">※
  ここでは最初にサイトを訪問した時のUXではなく、サイト内のリンクをクリックしたときの動作にフォーカスします</p>






<div className="mt-8 flow-root">
  <div className="-mx-4 -my-2 overflow-x-auto sm:-mx-6 lg:-mx-8">
    <div className="inline-block min-w-full py-2 align-middle sm:px-6 lg:px-8">
      <table className="min-w-full divide-y divide-gray-300">
        <caption className="caption-top text-left font-bold">ページ遷移技術の比較</caption>
        <thead>
        <tr>
          <th scope="col" className="py-3.5 pl-4 pr-3 text-left text-sm font-semibold text-gray-900 sm:pl-3">技術</th>
          <th scope="col" className="min-w-28 px-3 py-3.5 text-left text-sm font-semibold text-gray-900">データロード</th>
          <th scope="col" className="min-w-28 px-3 py-3.5 text-left text-sm font-semibold text-gray-900">ローダー表示</th>
          <th scope="col" className="min-w-28 px-3 py-3.5 text-left text-sm font-semibold text-gray-900">prefetch</th>
          <th scope="col" className="min-w-28 px-3 py-3.5 text-left text-sm font-semibold text-gray-900">セキュリティ</th>
          <th scope="col" className="px-3 py-3.5 text-left text-sm font-semibold text-gray-900">その他</th>
        </tr>
        </thead>
        <tbody className="bg-white">
        <tr key={1} className="even:bg-gray-50">
          <td className="whitespace-nowrap py-4 pl-4 pr-3 text-sm font-medium text-gray-900 sm:pl-3">[ネイティブ(MPA)](/api/hotwire/users)</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">先にロード</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">する</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">しない</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">○</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">JavaScript, CSSは要再読み込み</td>
        </tr>
        <tr key={2} className="even:bg-gray-50">
          <td className="whitespace-nowrap py-4 pl-4 pr-3 text-sm font-medium text-gray-900 sm:pl-3">[Hotwire (Turbo Drive)](/api/hotwire/users)</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">先にロード</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500"><StyledLink
              href="https://turbo.hotwired.dev/handbook/drive#displaying-progress">する</StyledLink></td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500"><StyledLink
              href="https://turbo.hotwired.dev/handbook/drive#prefetching-links-on-hover">する</StyledLink></td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">○</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">hoverでprefetch</td>
        </tr>
        <tr key={3} className="even:bg-gray-50">
          <td className="whitespace-nowrap py-4 pl-4 pr-3 text-sm font-medium text-gray-900 sm:pl-3">[Next SSG](/users_ssg)</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">先にロード</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">要作成</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500"><StyledLink
              href="https://nextjs.org/docs/pages/api-reference/components/link#prefetch">する</StyledLink></td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">△ (要DAL)</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">動的なサイトでは使えないが、参考までに紹介</td>
        </tr>
        <tr key={4} className="even:bg-gray-50">
          <td className="whitespace-nowrap py-4 pl-4 pr-3 text-sm font-medium text-gray-900 sm:pl-3">[Next useEffect](/users)</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">後にロード</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">要作成</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500"><StyledLink
              href="https://nextjs.org/docs/pages/api-reference/components/link#prefetch">静的な部分まで</StyledLink></td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">△ (要DAL)</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">useEffect内のfetchはprefetchされない</td>
        </tr>
        <tr key={5} className="even:bg-gray-50">
          <td className="whitespace-nowrap py-4 pl-4 pr-3 text-sm font-medium text-gray-900 sm:pl-3">[Next page router SSR](/users_ssr)</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">先にロード</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">要作成</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">しない</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">△ (要DAL)</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">SSRを使うとprefetchしない</td>
        </tr>
        <tr key={6} className="even:bg-gray-50">
          <td className="whitespace-nowrap py-4 pl-4 pr-3 text-sm font-medium text-gray-900 sm:pl-3">[Next app router Server component](/users_app)</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">先にロード</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">要作成</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500"><StyledLink
              href="https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching">静的な部分まで</StyledLink></td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">△ (要DAL)</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">dynamic componentを使った場合はloading.jsのところまでprefetch</td>
        </tr>
        </tbody>
      </table>
    </div>
  </div>
</div>

<H2WithHash id="installing-turbo">Turboの実装</H2WithHash>

Hotwireは[Turbo](https://turbo.hotwired.dev)/[Stimulus](https://stimulus.hotwired.dev)/[Strada](https://strada.hotwired.dev)の３つのパーツからなっています。ウェブで使用するのはTurboとStimulusですが、双方ともJavaScriptのファイルを読み込むだけで使用できます。ここでは[Turbo Drive](https://turbo.hotwired.dev/handbook/drive)を使用しますので、TurboのJavaScriptファイルを読み込みます。

**繰り返しますがMPAのページにTurboのJavaScriptファイルを読み込むだけで、Turbo Driveによる画面遷移が手に入ります。** インストール方法はファイルを読み込むだけです。[公式ドキュメント](https://turbo.hotwired.dev/handbook/installing)を確認してください。

本サイトではnpm等を使用せずに、コンパイル済みのJavaScriptファイルをダウンロードしてインストールしました。TurboのJavaScriptファイルは`public/hotwire/javascript/turbo.es2017-esm.js`にダウンロードされており、`templates/layouts/header.ejs`から参照されています。


**templates/layouts/header.ejs**
```html
<head>
  ...
  <script src="/hotwire/javascript/turbo.es2017-esm.js" data-turbo-track="reload" type="module"></script>
  ...
</head>
```

Turbo Driveを導入した時の効果は[デモページ](/api/hotwire/users)でご確認ください。


<H2WithHash id="page-transition-ux">ページ遷移のUX</H2WithHash>

本サイトでは、各技術を使った際のUXを確認していただくために、デモを用意しています。上の表の各技術名をクリックして、実際にUXをご体験ください。

### SPAの効果

上記の表に挙げた技術は、ネイティブを除いて、全てSPA ([Single-page Application: シングルページアプリケーション](https://ja.wikipedia.org/wiki/シングルページアプリケーション))です。Next.jsの場合はSSRであっても、２つ目のページはSPA的に遷移します。

ここでいうSPA的というのは、ページ切り替え時に[AJAX](https://ja.wikipedia.org/wiki/Ajax)等を使っていて、一見するとページ全体は切り替わっているものの、裏でロードされたJavaScriptやCSSはそのまま残しているという意味です。先のページのメモリ等を残しているため、よりスムーズなページ切り替えが可能になり、またキャッシュなどのパフォーマンス最適化の工夫がしやすくなっています。

ただし最近の高性能マシンではJavaScriptやCSSを読み込まないことによる効果はわずかであり、ほとんど感じることができません。実際[Astro](https://astro.build)などのフレームワークはSSRをするものの、２ページ目のSPA的遷移は省略しています。

SPA的な画面遷移の効果を強く感じさせてくれるのは、次に紹介するprefetchと組み合わせた時です。

### Prefetchの効果

[Turbo Driveをインストール](#installing-turbo)するだけで、ページ遷移はヌルサクになります。ネイティブな画面遷移とTurbo Driveによる[画面遷移を比べていただくと](/api/hotwire/users)一目瞭然です。

この効果のほとんどは[prefetch](https://turbo.hotwired.dev/handbook/drive#prefetching-links-on-hover)によるものです。マウスカーソルがリンクの上をホバーした時に、**フライング**をしてサーバにリクエストを飛ばします。そして実際にユーザがリンクをクリックしたとき、すでにリンク先ページは読み込まれていますので、瞬間的に画面遷移ができます。

### Next.jsのprefetchは条件によっては動かない

Next.jsにもprefetchがあります。しかし多くのケースでは効果がありません。Pages routerの場合、SSRのページではprefetchは効果がありません。またApp routerで[Dynamic rendering](https://nextjs.org/docs/app/building-your-application/rendering/server-components#dynamic-rendering)の場合は最初の`loading.js`ファイルまでしかprefetchしませんので、[prefetchはローディング画面の表示を早めてくれるだけ](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)の効果しかありません。逆に言うと、Pages routerのSSGやApp routerのStatic renderingの場合ならprefetchが有効になります。

本サイトの例を見ても、[Next SSGの場合](/users_ssg)はヌルサクな画面遷移をしますが、[Next useEffect](/users)、[Next app router](/users_app)の場合はまずはローダー画面だけがすぐに表示され、後になってちゃんとデータのある画面が現れます。そして[Next SSR](/users_ssr)の場合はクリック直後はページが変わらず、データのある画面が現れるのが遅れます。

このようにNext.jsはprefetch機能はありますが、機能するのは静的なページのところまでです。動的なコンテンツはprefetchされません。したがって動的コンテンツが多いサイトの場合はprefetchの効果がありません。なお本サイトは動的コンテンツのサイトを主眼に置いているため、App routerのキャッシュは極力オフにしており、全てのページは[Dynamic rendering](https://nextjs.org/docs/app/building-your-application/rendering/server-components#dynamic-rendering)させています。

<div className="mt-12">
  <div className="w-max-[560px] flex justify-center">
    <iframe className="aspect-video" src="https://www.youtube.com/embed/UWluEz8YPbo?si=ZPz6s2MWPQShzH6q"
            title="YouTube video player" frameBorder="0"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
            referrerPolicy="strict-origin-when-cross-origin" allowFullScreen></iframe>
  </div>
</div>
<div className="mt-12">
  <Image src={transitionImage} alt="Page Transition image"></Image>
</div>

### キャッシュの効果

Turbo Driveには[仕組みをほとんど理解していなくても安心して使用できるキャッシュ](https://turbo.hotwired.dev/handbook/building#understanding-caching)があります。多くの場合、キャッシュを導入すると予想しない動きが起きてしまい、うまく利用するのが困難です。最近で言えば、Next.jsでキャッシュを導入してみたものの、[評判が悪くてv15でデフォルトをキャッシュオフにした](https://nextjs.org/blog/next-15-rc#caching-updates)のは記憶に新しいところです。

Turbo Driveではプレビューとしてキャッシュを使用し、同時にサーバにリクエストを投げます。サーバから最新のページを受け取ると、プレビューの内容に入れ替えますので、古い情報が表示されたままになる心配がありません。その一方でプレビュー画面が瞬時に表示されますので、ユーザとしてはページ遷移が瞬間的に起こったように感じます。

このようにprefetchだけでは完全に瞬間的に表示できないケースであっても、すでに訪問済みのページであれば瞬間的に遷移しているように感じられます。Next.jsでデフォルトオフになったキャッシュの弊害がなく、利点しかないものになっています。



<H2WithHash id="security">セキュリティ: データ漏洩</H2WithHash>

ここではサーバからブラウザに機密性の高い情報が流れてしまうデータ漏洩の問題を取り上げます。上記の各方式は、サーバからブラウザにデータを渡す仕組みが異なります。ネイティブとTurbo DriveはHTMLのみを送ります。Next.js pages routerのSSRはHTMLに加え、React Hydration用のデータを送り、一方でapp routerはServer Componentの場合はHTMLに加えてRSC payloadを送ります。またuseEffectの中からfetchをする場合はJSON APIを送ります。

用いる方式の違いにより、データ漏洩のリスクおよび注意しなければならないポイントが異なります。ここでは実際のデモを見せながら、具体的に紹介します。

### HTMLだけを送る場合はリスクが少ない

ネイティブ(MPA)及ぼHotwireでは、サーバはHTML<strong>のみ</strong>をブラウザに送ります。HTMLには画面に表示される情報しかありません。そのため、意図しないデータをブラウザに送ってしまう可能性は低く、データ漏洩のリスクは少ないと言えます。

またユーザの権限によって見せるべきデータを変えなければならないときは、controllerもしくはviewテンプレートの中で出し分けることが一般的で、追加のセキュリティーレイヤーなどは不要です。

### JSONを送る場合は注意が必要

`useEffect`を使う場合は、`useEffect`の中からサーバのJSON APIに対してデータfetchをすることが一般的です。このAPIは一般にバックエンドのエンジニアが管理し、フロントエンドと合意したAPI設計に基づいて、出すべくデータと隠しておくべきデータを明確に管理します。その結果、データ漏洩が起こりにくい体制になっています。

一方でNext.jsによるSSG/SSRページ作成は、フロントエンドに任されることが多くなります。しかし実際には、Next.jsも（見えないところで）JSON APIが作られます。`getStaticProps()`, `getServerSideProps()`の返り値がそのままJSON APIになるのです。このJSON APIは２回目以降のページ遷移の時にそのままサーバからブラウザに送られます。また初回ロードの時も、SSRのHTMLの最後に、hydration用のデータとしてブラウザに送られます。このように`getStaticProps()`, `getServerSideProps()`の返り値はそのままブラウザに送られます。

`useEffect`の時のJSON APIの時と異なり、`getStaticProps()`, `getServerSideProps()`の返り値を明確に取り決めることはないと思います。しかしここで隠すべきデータをしっかりブロックしなければ、機密データは漏洩してしまいます。

### セキュリティのデモ

本デモでは、敢えてセキュリティ上問題のあるコードをバックエンドで書いています。セキュリティの問題を浮き彫りにするためです。

具体的には`User repository`がそのまま`password_digest`(秘密の情報)を返してしまうようにしています。また各エンドポイントでも`password_digest`をブロックする処理を行っていません。

* [ネイティブ画面遷移(MPA)](/api/hotwire/users)および[Turbo Drive](/api/hotwire/users)を使っている場合は`password_digest`は漏洩しません。レスポンスにはHTMLしか含まれないので、画面に表示しない内容はブラウザに送信されないためです。ブラウザの検証画面のネットワークタブを確認し、送信されてくる各ファイルの中身を見ても、`password_digest`の情報はありません。
* [Next.js useEffect](/users)の時は`/api/users`からのJSONレスポンスに`password_digest`が出てしまうように作ってありますので、ここから漏洩します。しかしこのようなAPIは注意深く設計されることがほとんどだと思いますので、問題にはなりにくいと考えられます。
* Next.js Pages
routerの[SSG](/users_ssg)および[SSR](/users_ssr)の時は、最初にダウンロードされるHTMLファイル最下部の`script`タグ中に`password_digest`が漏洩します。これはhydration用のデータであり、HTMLに`password_digest`がレンダリングされるかどうかに関わらず含まれます。またページ遷移をするたびにダウンロードされるJSONファイルにも漏洩します。
* [Next.js App routerのServer componentだけ](/users_app)を使っている場合は`password_digest`は漏洩しません。RSC
payloadはHTMLにレンダリングされる内容しか含まないためです。しかしServer componentの中にClient
componentを埋め込んでいる場合は[データが漏洩する可能性があります](https://zenn.dev/moozaru/articles/d270bbc476758e)ので、要注意です。


Next.jsをセキュアにする場合は`User repository`のデータをそのままコンポーネントに渡さず、[Data Access
Layer](https://nextjs.org/blog/security-nextjs-server-components-actions#data-access-layer)を作り、この中で権限に応じて必要なデータのみを含むDTO(Data
Transfer Object)を作成することが公式ページで奨励されています。
Reactの方でも[React
Taint API](https://nextjs.org/docs/app/building-your-application/data-fetching/patterns#preventing-sensitive-data-from-being-exposed-to-the-client)で対策されていく見込みですが、ただしこれはどちらかというと注意喚起のメカニズムだけであり、対応は別途必要になりそうです。

一方でHotwireの場合は、HTMLを出力するテンプレートファイル自身がこのようなData Access Layerの役割を果たしているとも言えます。実際、権限チェックなどはview Templateの中でやることが多いです。不要な情報が漏れ出ている場合は画面でもすぐに確認できますので、安全性が高いと言えます。

結論としてMPAやTurbo Driveを使用するときに比べ、Next.jsはデータ漏洩に神経を使う必要がありそうです。

<div className="mt-12">
  <div className="w-max-[560px] flex justify-center">
    <iframe className="aspect-video" src="https://www.youtube.com/embed/LxLhCviX8iQ?si=wjTL03S_bw7k25OF"
            title="YouTube video player" frameBorder="0"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
            referrerPolicy="strict-origin-when-cross-origin" allowFullScreen></iframe>
  </div>
</div>



export default function ({children}) {
  return <CommentaryLayout
    title="Page Transitions"
    subtitle="ページ遷移"
    section="Commentary">
    <MDXRenderer>{children}</MDXRenderer>
  </CommentaryLayout>
}
