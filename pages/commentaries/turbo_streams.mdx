import MDXRenderer from "../../components/MDXRenderer";
import CommentaryLayout from "../../components/CommentaryLayout";
import Image from "next/image"
import cartWithFramesReact from "@/public/images/cart-with-frames-react.webp"
import cartWithTurboStreams from "@/public/images/cart-with-turbo-streams.webp"

## Turbo Streamsは比較的特殊なケースで使う ===use-turbo-streams-for-relatively-special-cases===

Turboには[Turbo Drive, Turbo Frames, Turbo Streamsがあり、適宜使い分ける](/commentaries/tabbed_menus#turbo-ranking)ことは別途紹介しました。またTurbo DriveとTurbo Framesで大半のケースがカバー可能で、Turbo Streamsは比較的特殊なケースで使用するとも述べました。

ただし、Turbo Streamsの方が良いケースは間違いなくあります。またTurbo FramesよりもTurbo Streamsを好み人もいます。

人によって好みが異なる以上、単純にこれがTurbo Streamsの使いどき、あれがTurbo Framesの使いどきを紹介することはできません。そこでここではTurbo Streamsならではの特徴を紹介したいと思います。特徴を理解した上で、適宜判断していただければと思います。

## Turbo Streams固有の機能 ===features-exclusive-to-turbo-streams===

<div className="mt-8 flow-root">
  <div className="-mx-4 -my-2 overflow-x-auto sm:-mx-6 lg:-mx-8">
    <div className="inline-block min-w-full py-2 align-middle sm:px-6 lg:px-8">
      <table className="divide-y divide-gray-300">
        <caption className="caption-top text-left font-bold">Turbo Streams固有の機能</caption>
        <thead>
        <tr>
          <th scope="col" className="py-3.5 pl-4 pr-3 text-left text-sm font-semibold text-gray-900 sm:pl-3">機能</th>
          <th scope="col" className="min-w-28 px-3 py-3.5 text-left text-sm font-semibold text-gray-900">用途</th>
          <th scope="col" className="min-w-80 px-3 py-3.5 text-left text-sm font-semibold text-gray-900">備考</th>
        </tr>
        </thead>
        <tbody className="bg-white">
        <tr className="even:bg-gray-50">
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">Web Socketsに応答</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">Pollingを使わずにリアルタイムで<br />サーバの情報を反映したい時<br />リアルタイムチャットなど</td>
          <td className="px-3 py-4 text-sm text-gray-500"></td>
        </tr>
        <tr className="even:bg-gray-50">
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">部分置換以外の更新</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">置換だけでなく、<br />削除や追加などをしたい時</td>
          <td className="px-3 py-4 text-sm text-gray-500"></td>
        </tr>
        <tr className="even:bg-gray-50">
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">レスポンスを柔軟に<br />指定できる</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">POSTに対して簡素にレスポンスしたい時<br />例えば「いいね」ボタンの実装など</td>
          <td className="px-3 py-4 text-sm text-gray-500">Turbo Framesは`form`からの非GETのリクエストに対して、[POST/Redirect/GETパターン](https://en.wikipedia.org/wiki/Post/Redirect/Get)を前提としいて 、[POST後はstatus 303を期待し、status 200を無視する](https://turbo.hotwired.dev/handbook/drive#redirecting-after-a-form-submission)。これを嫌うときに使う</td>
        </tr>
        <tr className="even:bg-gray-50">
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">画面の複数箇所の更新</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">画面上で離れた箇所を<br />効率的に更新したい時</td>
          <td className="px-3 py-4 text-sm text-gray-500">Turbo Framesで画面の離れた複数箇所を同時更新する時は、全部を覆う大きいTurbo Frameを作る(Reactでいう[stateのリフトアップ](https://ja.react.dev/learn/sharing-state-between-components)と同じ)。一方でTurbo Streamsなら個別に変更できる</td>
        </tr>
        <tr className="even:bg-gray-50">
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">サーバ側から<br />ブラウザを細かく制御</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">状況に応じてレスポンスを返したり、<br />refreshしたりを細かく制御したいとき</td>
          <td className="px-3 py-4 text-sm text-gray-500"></td>
        </tr>
        <tr className="even:bg-gray-50">
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">タグを追加しなくても使える</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">&lt;turbo-frame&gt;を差し込めない時</td>
          <td className="px-3 py-4 text-sm text-gray-500"><code>table</code>の中は使用できるタグがHTMLの規約上制限されており、&lt;turbo-frame&gt;が使いにくい</td>
        </tr>
        </tbody>
      </table>
    </div>
  </div>
</div>

以下、（すべては紹介できないかもしれないが）Turbo Streams固有の各機能の使い方を紹介します。

## 画面の複数箇所の更新 ===updating-multiple-segments===

[ショッピングカードの簡単なデモ](/api/hotwire/cart_streams)を用意しています。製品を選択してカートに追加すると、同時に２つのことが起こります。

* "Add to Cart"ボタンが"Added to Cart"バッジに変更される
* 画面右上のカートアイコン(Cart Icon)で追加された品目数が更新される

このUIを実現する方法はいくつもあります。

### Turbo Frames/Reactの考え方（リフトアップ） ===multi-segment-with-turbo-frames-or-react-concept===

Turbo FramesもReactも発想は同じなので、一緒に紹介します。

"Add to Cart"ボタンとCart Iconは共通の`cart`ステートによって同時に更新されます。しかし"Add to Cart"ボタンとCart Iconは離れていますので、[ステートのリフトアップ](https://ja.react.dev/learn/sharing-state-between-components#lifting-state-up-by-example)を行います。つまり双方のコンポーネントを内包するより上位のコンポーネントに`cart`ステートを持たせ、更新された時は上位コンポーネント以下を再描画することで、同時更新を実現します。

もちろん無駄が発生します。今回のケースでいうと、他の製品の"Add to Cart"ボタンは全く変更されないのに、再レンダリングされてしまいます。しかし通常は大きな負荷ではなく、またキャッシュなどの方法で最適化も可能なので特に気にしません。

<figure className="my-4">
  <figcaption className="font-bold">Turbo FramesやReactによる実装方法</figcaption>
  <Image src={cartWithFramesReact} alt="Cart with Turbo Frames and React" />
</figure>

### Turbo Framesによる実装方法 ===implement-multi-segment-with-turbo-frames===

Turbo Framesの場合は上位コンポーネントとして、"Add to Cart"ボタンとCart Iconを内容する場所に`<turbo-frame id="cart">`タグを配置するだけです。それ以外は普通のMPAと変わりません。[コードはGitHub](https://github.com/naofumi/hotwire_and_next/tree/main/templates/cart_frames)に用意していますので、ご確認ください。

#### コード

**templates/cart_frames/index.ejs**
```html
<%- include("../layouts/header.ejs") -%>
<div class="my-10 px-4 sm:px-6 lg:px-8">
  <turbo-frame id="cart">
    ...
  </turbo-frame>
</div>
<%- include("../layouts/footer.ejs") -%>
```

* `<turbo-frame id="cart">`で囲むことによって、"Add to Cart"をクリックしたときの動作は`turbo-frame`の中だけに影響するようになります。今回のケースではボタンをクリックしてもスクロール位置が変わらないという効果が得られます（スクロール位置が変わっても良いのであれば、`turbo-frame`で囲む必要がありません）

**templates/cart_frames/_product_add_button.ejs**
```html
<form method="post" action="/api/hotwire/cart_frames/add_to_cart">
  <input type="hidden" name="product_id" value="<%= product.id %>">
  <button type="submit"
          data-turbo-submits-with="adding..."
          class="btn-primary border border-orange-600">Add to Cart</button>
</form>
```

* "Add to Cart"ボタンは通常の`form`タグで`/api/hotwire/cart_frames/add_to_cart`にPOSTリクエストを投げています（パラメータとして`product_id`も送信）。

**pages/api/hotwire/cart_frames/add_to_cart.ts**
```ts
// Next.js API route support: https://nextjs.org/docs/api-routes/introduction
import type {NextApiRequest, NextApiResponse} from "next";
import {getCookie, setCookie} from "cookies-next"
import {Cart} from "@/repositories/cart";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  if (req.method !== "POST") { throw new Error("Bad request"); }

  const productId: string = req.body.product_id
  const cartString = getCookie("cart", {req, res})
  const cart: Cart = cartString ? JSON.parse(cartString) : {}

  cart[productId] = 1
  setCookie("cart", JSON.stringify(cart), {res, req})

  res.redirect(303, process.env.URL + "/api/hotwire/cart_frames")
}
```

* `/api/hotwire/cart_frames/add_to_cart`では下記のように、`product_id`をcookieに保存します。そして**ここがとても重要なのですが、元のページ`/api/hotwire/cart_frames`にStatus 303のredirectをします**。
* **Redirectすることの大きなメリットはコードが簡単になるということです**。POST後の再描画のコードは全く不要で、元のページを単純に再利用できます。
* Turbo Drive, Turbo Framesを使用する際、`form`タグはブラウザネイティブのものと異なる動作をします。特に重要なのは[POST/redirect/GETパターン](https://en.wikipedia.org/wiki/Post/Redirect/Get)が必須となることです。[POSTが成功した場合はStatus 200のレスポンスは無視され、Status 303によるredirectだけが可能になります(Status 302も許容)](https://turbo.hotwired.dev/handbook/drive#redirecting-after-a-form-submission)。Redirectせずに、Status 200で再レンダリングしたHTMLを送ればネットワーク通信が1回減らせますが、それはできないということです。この辺りは分かりにくいので、別途解説予定です。

なおPOST/redirect/GETパターンは古くからベストプラクティスとされていたもので、特に画面リフレッシュ時に同じPOSTを誤って２回送信してしまうのを防ぐ効果がありました。ただしAJAXで非同期通信を行い、URLを変更せずに画面の一部置換を行うUIの場合はこの問題が起こりません。Turbo Drive, Turbo FramesはJavaScriptがオフの場合も動作するように設計されており、おそらくその影響もあって簡便なPOST/redirect/GETパターンを前提としていると考えられます。（なお[Next.js Server Actionもredirectを使います](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations#redirecting)）

#### まとめ

* MPAと比べ、`turbo-frame`タグをつけるだけで実装できる
* POST/redirect/GETパターンを使わないといけないので、"Add to Cart"を押してから２回ネットワーク通信が必要になる。ネットワークが遅い場合は遅延が大きくなる

### Reactによる実装方法 ===implement-multi-segment-with-react===

上述したようにReactによる実装とTurbo Framesによる実装は考え方が似ています。複数箇所を更新するために[ステートをリフトアップ](https://ja.react.dev/learn/sharing-state-between-components#lifting-state-up-by-example)します。ただしMPAをシンプルに改良するTurbo Framesと比べて、Reactは色々な工夫ができます。それを紹介します。

React版は下記の構成になります。

* ショッピングカートUIでは製品情報(`products`)とカート情報(`cart`)の２つが必要。Hotwireと異なり、ReactはCSR (Client Side Rendering)を行うので、ブラウザの中でこの２つを統合してHTMLをレンダリングできる
* 製品情報(`products`)をもとにしたレンダリングはサーバ側でSSR (Server Side Rendering)によって行う。これは最初の描画の高速化とSEOに有利。
* カート情報(`cart`)はCSRを使ってブラウザの中で行う。このため、カートを更新したときに必要なサーバとの通信を最小化できる

以下、コードを見ていきます([GitHubに掲載](https://github.com/naofumi/hotwire_and_next/tree/main/pages/cart))。[デモ](/cart)はこちらでご確認いただけます。

#### コード

**pages/cart/index.tsx**
```tsx
...

export async function getServerSideProps() {
  const response = await fetch(process.env.URL + "/api/products");
  const data = await response.json();

  return {props: {products: data}}
}

export default function CartPage({products}: { products: Product[] }) {
  const [cart, setCart] = useState<Cart | null>(null)

  useEffect(() => {
    fetch("/api/cart")
      .then(response => response.json())
      .then(data => setCart(data))
  }, [])

  function addToCart(productId: number) {
    fetch("/api/cart/add_to_cart", {
      method: "POST",
      headers: {
        "Accept": "application/json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({product_id: productId}),
    }).then(response => response.json())
      .then(data => setCart(data));
  }

  function clearCart() {
    fetch("/api/cart/reset", {
      method: "POST"
    }).then(response => response.json())
      .then(data => setCart(data))
  }

  return (
    <Layout>
      <div className="my-10 px-4 sm:px-6 lg:px-8">
        <div className="sm:flex sm:items-center">
           ...
            <div id="cart_icon">
              {cart
                ? <CartIcon cart={cart}/>
                : <span>Loading...</span>}
            </div>
           ...
        </div>
        <div className="mt-8 flow-root">
           ...
            <tbody className="divide-y divide-gray-200 bg-white">
            {
              products.map((product, i) => {
                return (<tr key={i} className="divide-x divide-gray-200">
                  ...
                  <td className="text-center whitespace-nowrap py-4 pl-4 pr-4 text-sm text-gray-500 sm:pr-0">
                    {cart
                      ? cart[product.id.toString()]
                        ? <AddedBadge/>
                        : <ProductAddButton product={product} addToCart={addToCart}/>
                      : <span>Loading...</span>
                    }
                  </td>
                </tr>)
              })
            }
            </tbody>
           ...
        </div>
      </div>
    </Layout>
  )
}
```

* `products` `cart`のステートはリフトアップされているので、すべて`CartPage`コンポーネントが持っている
* ステートを操作するイベントハンドラの`addToCart()`, `clearCart()`もリフトアップの関係でここに記載している
* `useEffect`、`addToCart()`、`clearCart()`もすべて`setCart(data)`だけで、カート更新後の再レンダリングを実施している。`cart`の情報だけをサーバから受け取っといる
* Turbo Framesの場合は`form`タグを書くだけで、別途イベントハンドラを記載する必要がなかった。Reactの場合はイベントハンドラをカスタムで記述することに加え、それをリフトアップして下位のコンポーネントにpropsとして渡していくところが幾分か複雑になっている

#### まとめ

* MPAを少しだけ改変するTurbo Framesと比べると、特にイベントハンドラ周りが多少複雑になっている
* POST/redirect/GETパターンを使わないので、ネットワーク通信が１回で済む。その分、レスポンスが高速になり、特にネットワークが遅い場合はUI/UXが優れている
* `products`は最初に読み込んだきりで、あとは`cart`情報だけをサーバ通信するので、ネットワーク負荷、サーバ負荷が減らせる
* `cart`が更新されるとブラウザ側で製品リストの再レンダリングは行うが、サーバ側では行わない。よってサーバへの負荷は少ない

### Turbo Streamsによる実装方法 ===implement-multi-segment-with-turbo-streams===

[Turbo Streamsを使った実装のデモ](/api/hotwire/cart_streams)を用意していますのでご覧ください。また[コードはGitHubに載せています](https://github.com/naofumi/hotwire_and_next/tree/main/templates/cart_streams)。

Turbo Streamsを使った場合は、内包する上位のコンポーネントすべてが再レンダリングされるのではなく、"Add to Cart"ボタンとCart Iconのみが再描画されます。

<figure className="my-4">
  <figcaption className="font-bold">Turbo Streamsによる実装方法</figcaption>
  <Image src={cartWithTurboStreams} alt="Cart with Turbo Streams" className="w-1/2 mx-auto" />
</figure>

"Add to Cart"ボタンとCart Iconをそれぞれ別個に再描画するため、サーバから送られてくるレスポンスは２つのパーツから構成されていて、それぞれの箇所のアップデートを担当します。どこをアップデートするかは`target=`属性を使って、更新先の要素の`id`を指定します。

**templates/cart_streams/add_to_cart.ejs**

```html
<turbo-stream action="update" target="<%= `product_${productId}` %>">
  <template>
    <%- include("_added_badge.ejs") %>
  </template>
</turbo-stream>

<turbo-stream action="update" target="cart_icon">
  <template>
    <%- include("_cart_icon.ejs", {cart}) %>
  </template>
</turbo-stream>
```




### Turbo Streamsのメリット ===multi-segment-turbo-streams-benefits===

Turbo Streamsのように更新箇所を細かく指定できるメリットは、ブラウザのステートを維持しつつ、サーバ負担も最小化し、高速に再描画ができる点です。一方でデータの相互依存関係、つまり何を更新したら何が変更されるかを正確に把握している必要があります。更新される箇所が多くなると、管理が難しくなってきます。

その点、すべてを再レンダリングするアプローチではデータの相互依存を考える必要がありません。データが単方向にしか流れないためです。Reactの[単方向データフロー](https://ja.react.dev/learn/thinking-in-react#step-2-build-a-static-version-in-react)もこの考え方です。

このように、シンプルでかつ変更が局所的な時はTurbo Streamsのメリットが大きくなります。逆に変更箇所が多く、複雑な場合は、今後のメンテナンス性も含めて慎重に検討した方が良いでしょう。

ただし、すべての変更箇所を囲む大きなTurbo Streamsを使うこともできます。他のメリット・デメリットも考慮して総合的に判断する必要があります。

export default function NewTabbedMenus({children}) {
  return <CommentaryLayout
    title="Turbo Streams"
    subtitle="Turbo Streamsが必要なケース"
    section="Commentary">
    <MDXRenderer>{children}</MDXRenderer>
  </CommentaryLayout>
}
