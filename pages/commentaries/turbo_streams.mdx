import MDXRenderer from "../../components/MDXRenderer";
import CommentaryLayout from "../../components/CommentaryLayout";
import Image from "next/image"
import cartWithFramesReact from "@/public/images/cart-with-frames-react.webp"
import cartWithTurboStreams from "@/public/images/cart-with-turbo-streams.webp"

## Turbo Streamsは比較的特殊なケースで使う ===use-turbo-streams-for-relatively-special-cases===

Turboには[Turbo Drive, Turbo Frames, Turbo Streamsがあり、適宜使い分ける](/commentaries/tabbed_menus#turbo-ranking)ことは別途紹介しました。またTurbo DriveとTurbo Framesで大半のケースがカバー可能で、Turbo Streamsは比較的特殊なケースで使用するとも述べました。

ただし、Turbo Streamsの方が良いケースは間違いなくあります。またTurbo FramesよりもTurbo Streamsを好み人もいます。

人によって好みが異なる以上、単純にこれがTurbo Streamsの使いどき、あれがTurbo Framesの使いどきを紹介することはできません。そこでここではTurbo Streamsならではの特徴を紹介したいと思います。特徴を理解した上で、適宜判断していただければと思います。

## Turbo Streams固有の機能 ===features-exclusive-to-turbo-streams===

<div className="mt-8 flow-root">
  <div className="-mx-4 -my-2 overflow-x-auto sm:-mx-6 lg:-mx-8">
    <div className="inline-block min-w-full py-2 align-middle sm:px-6 lg:px-8">
      <table className="divide-y divide-gray-300">
        <caption className="caption-top text-left font-bold">Turbo Streams固有の機能</caption>
        <thead>
        <tr>
          <th scope="col" className="py-3.5 pl-4 pr-3 text-left text-sm font-semibold text-gray-900 sm:pl-3">機能</th>
          <th scope="col" className="min-w-28 px-3 py-3.5 text-left text-sm font-semibold text-gray-900">用途</th>
          <th scope="col" className="min-w-80 px-3 py-3.5 text-left text-sm font-semibold text-gray-900">備考</th>
        </tr>
        </thead>
        <tbody className="bg-white">
        <tr className="even:bg-gray-50">
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">Web Socketsに応答</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">Pollingを使わずにリアルタイムで<br />サーバの情報を反映したい時<br />リアルタイムチャットなど</td>
          <td className="px-3 py-4 text-sm text-gray-500"></td>
        </tr>
        <tr className="even:bg-gray-50">
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">部分置換以外の更新</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">置換だけでなく、<br />削除や追加などをしたい時</td>
          <td className="px-3 py-4 text-sm text-gray-500"></td>
        </tr>
        <tr className="even:bg-gray-50">
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">レスポンスを柔軟に<br />指定できる</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">POSTに対して簡素にレスポンスしたい時<br />例えば「いいね」ボタンの実装など</td>
          <td className="px-3 py-4 text-sm text-gray-500">Turbo Framesは`form`からの非GETのリクエストに対して、[POST/Redirect/GETパターン](https://en.wikipedia.org/wiki/Post/Redirect/Get)を前提としいて 、[POST後はstatus 303を期待し、status 200を無視する](https://turbo.hotwired.dev/handbook/drive#redirecting-after-a-form-submission)。これを嫌うときに使う</td>
        </tr>
        <tr className="even:bg-gray-50">
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">画面の複数箇所の更新</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">画面上で離れた箇所を<br />効率的に更新したい時</td>
          <td className="px-3 py-4 text-sm text-gray-500">Turbo Framesで画面の離れた複数箇所を同時更新する時は、全部を覆う大きいTurbo Frameを作る(Reactでいう[stateのリフトアップ](https://ja.react.dev/learn/sharing-state-between-components)と同じ)。一方でTurbo Streamsなら個別に変更できる</td>
        </tr>
        <tr className="even:bg-gray-50">
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">サーバ側から<br />ブラウザを細かく制御</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">状況に応じてレスポンスを返したり、<br />refreshしたりを細かく制御したいとき</td>
          <td className="px-3 py-4 text-sm text-gray-500"></td>
        </tr>
        <tr className="even:bg-gray-50">
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">タグを追加しなくても使える</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">&lt;turbo-frame&gt;を差し込めない時</td>
          <td className="px-3 py-4 text-sm text-gray-500"><code>table</code>の中は使用できるタグがHTMLの規約上制限されており、&lt;turbo-frame&gt;が使いにくい</td>
        </tr>
        </tbody>
      </table>
    </div>
  </div>
</div>

以下、（すべては紹介できないかもしれないが）Turbo Streams固有の各機能の使い方を紹介します。

## 画面の複数箇所の更新 ===updating-multiple-segments===

[ショッピングカードの簡単なデモ](/api/hotwire/cart_streams)を用意しています。製品を選択してカートに追加すると、同時に２つのことが起こります。

* "Add to Cart"ボタンが"Added to Cart"バッジに変更される
* 画面右上のカートアイコン(Cart Icon)で追加された品目数が更新される

HotwireおよびNext.jsでこのUIを実現する方法をいくつか検討し、考察していきます。

## Turbo Frames/Reactの考え方（ステートのリフトアップ） ===multi-segment-with-turbo-frames-or-react-concept===

Turbo FramesもReactもステートのリフトアップの発想は同じなので、一緒に紹介します。

"Add to Cart"ボタンとCart Iconは共通の`cart`ステートによって同時に更新されます。製品を新規にカートに追加すれば"Add to Cart"ボタンは"Added to Cart!"バッジになり、Cart Iconでは製品数が1つ増加します。しかし"Add to Cart"ボタンとCart Iconは離れていますので、[ステートのリフトアップ](https://ja.react.dev/learn/sharing-state-between-components#lifting-state-up-by-example)を行います。つまり双方のコンポーネントを内包するより上位のコンポーネントに`cart`ステートを持たせ、更新された時は上位コンポーネント以下を再描画することで、同時更新を実現します。

もちろん無駄が発生します。今回のケースでいうと、他の製品の"Add to Cart"ボタンは全く変更されないのに、再レンダリングされてしまいます。しかし通常は大きな負荷ではなく、またキャッシュなどの方法で最適化も可能なので特に気にしません。Turbo Framesの実装もReactの実装もこの考え方に沿っています。

<figure className="my-4">
  <figcaption className="font-bold">Turbo FramesやReactによる実装方法</figcaption>
  <Image src={cartWithFramesReact} alt="Cart with Turbo Frames and React" />
</figure>

## Turbo Framesによる実装 ===implement-with-turbo-frames===

Turbo Framesの場合は上位コンポーネントとして、"Add to Cart"ボタンとCart Iconを囲む場所に`<turbo-frame id="cart">`タグを配置するだけです。それ以外は普通のMPAと変わりません。[コードはGitHub](https://github.com/naofumi/hotwire_and_next/tree/main/templates/cart_frames)に用意していますので、ご確認ください。

### コード ===turbo-frames-code===

**templates/cart_frames/index.ejs**
```html
<%- include("../layouts/header.ejs") -%>
<div class="my-10 px-4 sm:px-6 lg:px-8">
  <turbo-frame id="cart">
    ...
  </turbo-frame>
</div>
<%- include("../layouts/footer.ejs") -%>
```

* `<turbo-frame id="cart">`で囲むことによって、"Add to Cart"をクリックしたときの動作は`turbo-frame`の中だけに影響するようになります。今回のケースではボタンをクリックしてもスクロール位置が変わらないという効果が得られます（スクロール位置が変わっても良いのであれば、`turbo-frame`で囲む必要すらなく、通常のMPAで十分なUI/UXが実現できます）

**templates/cart_frames/_product_add_button.ejs**
```html
<form method="post" action="/api/hotwire/cart_frames/add_to_cart">
  <input type="hidden" name="product_id" value="<%= product.id %>">
  <button type="submit"
          data-turbo-submits-with="adding..."
          class="btn-primary border border-orange-600">Add to Cart</button>
</form>
```

* "Add to Cart"ボタンは通常の`form`タグで`/api/hotwire/cart_frames/add_to_cart`にPOSTリクエストを投げています（パラメータとして`product_id`も送信）。これはMPAの場合と全く同じです
* 今回はTurbo Framesを使用していますので、`form`はTurboが処理します。そしてレスポンスから`<turbo-frame>`で囲まれているところだけが取り出され、画面の部分更新が行われます

**pages/api/hotwire/cart_frames/add_to_cart.ts**
```ts
// Next.js API route support: https://nextjs.org/docs/api-routes/introduction
import type {NextApiRequest, NextApiResponse} from "next";
import {getCookie, setCookie} from "cookies-next"
import {Cart} from "@/repositories/cart";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  if (req.method !== "POST") { throw new Error("Bad request"); }

  const productId: string = req.body.product_id
  const cartString = getCookie("cart", {req, res})
  const cart: Cart = cartString ? JSON.parse(cartString) : {}

  cart[productId] = 1
  setCookie("cart", JSON.stringify(cart), {res, req})

  res.redirect(303, process.env.URL + "/api/hotwire/cart_frames")
}
```

* `/api/hotwire/cart_frames/add_to_cart`では、`product_id`をcookieに保存します。そして**ここがとても重要なのですが、元のページ`/api/hotwire/cart_frames`にStatus 303のredirectをします**。
* **Redirectすることの大きなメリットはコードが簡単になるということです**。POST後の再描画のコードは全く不要で、元のページを単純に再利用できます。
* Turbo Drive, Turbo Framesを使用する際、`form`タグはブラウザネイティブのものと少し異なる動作をします。特に重要なのは[POST/redirect/GETパターン](https://en.wikipedia.org/wiki/Post/Redirect/Get)が必須となることです。[POSTが成功した場合はStatus 200のレスポンスは無視され、Status 303によるredirectだけが可能になります(Status 302も許容)](https://turbo.hotwired.dev/handbook/drive#redirecting-after-a-form-submission)。Redirectせずに、Status 200で再レンダリングしたHTMLを送ればネットワーク通信が1回減らせますが、それはできないということです。この辺りは分かりにくいので、別途解説予定です。

なおPOST/redirect/GETパターンは古くからベストプラクティスとされていたもので、特に画面リフレッシュ時に同じPOSTを誤って２回送信してしまうのを防ぐ効果がありました。ただしAJAXで非同期通信を行い、URLを変更せずに画面の一部置換を行うUIの場合はこの問題が起こりません。Turbo Drive, Turbo FramesはJavaScriptがオフの場合も動作するように設計されており、おそらくその影響もあって簡便なPOST/redirect/GETパターンを前提としていると考えられます。

### まとめ ===turbo-frames-summary===

* MPAと比べ、`turbo-frame`タグをつけるだけで実装できます
* POST/redirect/GETパターンを使わないといけないので、"Add to Cart"を押してから２回ネットワーク通信が必要になります。ネットワーク遅延が２倍になり、ネットワークが遅い場合はUI/UXへのインパクトが大きくなります

## Reactによる実装 ===implement-multi-segment-with-react===

上述したようにReactによる実装とTurbo Framesによる実装は考え方が似ています。複数箇所を更新するために[ステートをリフトアップ](https://ja.react.dev/learn/sharing-state-between-components#lifting-state-up-by-example)する作戦です。ただしMPAをベースとしてシンプルな改変だけを行うTurbo Framesと比べて、ReactはCSRも使えますので色々な工夫ができます。それを紹介します。

React版は下記の構成になります。

* ショッピングカートUIでは製品情報(`products`)とカート情報(`cart`)の２種類のデータが必要です。Hotwireの場合は完全にSSRなので、サーバで２種のデータを統合します。一方でReactはCSR (Client Side Rendering)を行えますので、ブラウザの中でこの２つを統合し、ブラウザでHTMLをレンダリングできます。今回はこの作戦を採用しました
* サーバ側のSSR (Server Side Rendering)では製品情報(`products`)だけを使って表を描画します。これは初回描画の高速化とSEOに有利にするためです
* SSRのページがブラウザに表示され、Hydrationが完了したのちに、`useEffect`を使ってサーバからカート情報(`cart`)が取得されます。これを使ってCSR (Client Side Rendering)で画面を再レンダリングします
* "Add to Cart"ボタンを押した時はカート情報(`cart`)のみをサーバから取得します。データ取得後、CSRで画面を再描画します

以下、コードを見ていきます([GitHubに掲載](https://github.com/naofumi/hotwire_and_next/tree/main/pages/cart))。[デモ](/cart)はこちらでご確認いただけます。

### コード ===react-code===

**pages/cart/index.tsx**
```tsx
...

export async function getServerSideProps() {
  const response = await fetch(process.env.URL + "/api/products");
  const data = await response.json();

  return {props: {products: data}}
}

export default function CartPage({products}: { products: Product[] }) {
  const [cart, setCart] = useState<Cart | null>(null)

  useEffect(() => {
    fetch("/api/cart")
      .then(response => response.json())
      .then(data => setCart(data))
  }, [])

  function addToCart(productId: number) {
    fetch("/api/cart/add_to_cart", {
      method: "POST",
      headers: {
        "Accept": "application/json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({product_id: productId}),
    }).then(response => response.json())
      .then(data => setCart(data));
  }

  function clearCart() {
    fetch("/api/cart/reset", {
      method: "POST"
    }).then(response => response.json())
      .then(data => setCart(data))
  }

  return (
    <Layout>
      <div className="my-10 px-4 sm:px-6 lg:px-8">
        <div className="sm:flex sm:items-center">
           ...
            <div id="cart_icon">
              {cart
                ? <CartIcon cart={cart}/>
                : <span>Loading...</span>}
            </div>
           ...
        </div>
        <ProductList products={products} cart={cart} addToCart={addToCart} />
      </div>
    </Layout>
  )
}
```

* `products` `cart`のステートはリフトアップされていますので、ステートはすべて`CartPage`コンポーネントが持っています。ステートはpropsで`CartIcon`, `ProductList`コンポーネントに渡されます
* ステートを操作するイベントハンドラの`addToCart()`, `clearCart()`もこのページにリフトアップされる必要があります。この関数もpropsで`CartIcon`, `ProductList`コンポーネントに渡されます
* `useEffect`、`addToCart()`、`clearCart()`はすべて`setCart(data)`でカート情報だけを取得します。`products`を再取得する必要がなくても再レンダリングできるためです
* Turbo Framesの場合は`form`タグを書くだけで、別途イベントハンドラを記載する必要がありませんでした。Reactの場合はイベントハンドラをカスタムで記述する必要があります

### まとめ ===react-summary===

* MPAを少しだけ改変したTurbo Framesの場合と比べると、特にイベントハンドラ周りが複雑になっています
* POST/redirect/GETパターンを使わないので、ネットワーク通信が１回で済みます。その分、レスポンスが高速になり、特にネットワークが遅い場合はUI/UXが優れています
* CSRの特徴を活かして、`products`と`cart`の情報を統合したレンダリングはブラウザで行なっています。おかげで"Add to Cart"ボタンをクリックしたとき、サーバからは`cart`情報のみを取得すれば十分です。ネットワーク負荷、サーバ負荷が減らせます

## Turbo Streamsによる実装 ===implement-turbo-streams===

Turbo Streamsの場合はTurbo Frames, Reactの場合と大きく異なり、ステートのリフトアップは行いません。その代わり、Cart Iconおよび"Add to Cart"ボタンの要素を個別に更新します。Turbo FramesおよびReactの場合は要素更新のロジックは別個に持たず、最初のレンダリングのロジックをそのまま使っていましたが、Turbo Streamsの場合は要素更新ロジックを別途用意する必要があります。

[Turbo Streamsを使った実装のデモ](/api/hotwire/cart_streams)を用意していますのでご覧ください。また[コードはGitHubに載せています](https://github.com/naofumi/hotwire_and_next/tree/main/templates/cart_streams)。

Turbo Streamsを使った場合は、内包する上位のコンポーネントすべてが再レンダリングされるのではなく、"Add to Cart"ボタンとCart Iconのみが再描画されます。

<figure className="my-4">
  <figcaption className="font-bold">Turbo Streamsによる実装方法</figcaption>
  <Image src={cartWithTurboStreams} alt="Cart with Turbo Streams" className="w-1/2 mx-auto" />
</figure>

### コード ===turbo-streams-code===

**pages/api/hotwire/cart_streams/add_to_cart.ts**
```ts
// Next.js API route support: https://nextjs.org/docs/api-routes/introduction
import type {NextApiRequest, NextApiResponse} from "next";
import {render} from "@/helpers/template-renderer"
import {getCookie, setCookie} from "cookies-next"
import {Cart} from "@/repositories/cart";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  if (req.method !== "POST") { throw new Error("Bad request"); }

  const productId: string = req.body.product_id
  const cartString = getCookie("cart", {req, res})
  const cart: Cart = cartString ? JSON.parse(cartString) : {}

  cart[productId] = 1
  setCookie("cart", JSON.stringify(cart), {res, req})

  const resultText = render("cart_streams/add_to_cart.ejs",
    {productId, cart}
  )

  res.appendHeader("Content-Type", "text/vnd.turbo-stream.html")
    .status(200)
    .send(resultText)
}
```

* Turbo Streamsの場合は(当然ではありますが)`<turbo-frame>`タグが不要なので、削除してあります (つまりMPAの状態まず戻します)
* 変更があるのは `pages/api/hotwire/cart_streams/add_to_cart.ts`と`templates/cart_streams/add_to_cart.ejs` – つまりカートに製品を追加し、画面を更新するところです
* 上記の`pages/api/hotwire/cart_streams/add_to_cart.ts`では`product_id`をcookieに保存後、`cart_streams/add_to_cart.ejs`テンプレートファイルを`Content-Type: text/vnd.turbo-stream.html`でブラウザに送信しています。Turbo Framesの場合、ここはStatus 303のredirectでした

**templates/cart_streams/add_to_cart.ejs**

```html
<turbo-stream action="update" target="<%= `product_${productId}` %>">
  <template>
    <%- include("_added_badge.ejs") %>
  </template>
</turbo-stream>

<turbo-stream action="update" target="cart_icon">
  <template>
    <%- include("_cart_icon.ejs", {cart}) %>
  </template>
</turbo-stream>
```

* `pages/api/hotwire/cart_streams/add_to_cart.ts`は"Add to Cart"ボタンとCart Iconをそれぞれ別個に更新する指示です。上の`turbo-stream`が"Add to Cart"ボタンの箇所、下の`turbo-stream`がCart Iconの箇所になります
* `target=`属性を使って、更新先の要素の`id`を指定します。
* レスポンスのheaderの`Content-Type: text/vnd.turbo-stream.html`を見て、ブラウザはこれがTurbo Stream応答であることを知ります。そして上記の２つの`turbo-stream`を適宜処理して、画面を更新します

### まとめ ===summary-turbo-streams===

* Turbo Framesに比べて更新箇所を細かく指定できます。余計な箇所を再レンダリングしません
* これを実現するために、「何をどのように更新するか」を指示しています。`<turbo-stream>`タグを使って宣言的に記述するため、ロジックはゴチャつきにくくなっています。それでもTurbo FramesやReactの場合はそもそも更新ロジックの記載が不要だったことを考えると、複雑になっています
* 更新ロジックが単純な場合は問題ありませんが、複雑になると場合はTurbo FramesもしくはMorphingを使って、更新ロジックそのものを不要にした方が良いでしょう

## React Server Actionsによる実装 ===implement-server-actions===

Reactは今までは`form`等によるデータ更新のための特に用意されていませんでした。しかしReact Server Componentsでは`form`関連の機能が新しく導入されています。Server Actionもそのうちの１つです。ここではServer Actionによるデータ更新と画面更新の方法を確認します。

[デモはこちら](/cart_app)に用意しています。また[コードはGitHub](https://github.com/naofumi/hotwire_and_next/tree/main/app/cart_app)にあります。

大雑把な特徴は下記のようになります

* `products`(製品情報)および`cart`(カート情報)は、そのデータを必要とするコンポーネントでそれぞれ取得します。従来のReactと異なり、[ステートのリフトアップ](/commentaries/turbo_streams#multi-segment-with-turbo-frames-or-react-concept)は行いません
* 同様に`cart`(カート情報)を更新する関数もリフトアップする必要がありません。その更新イベントが発生するコンポーネントに記述しています
* カード情報を更新するボタンは`form`と結びつけて、`form`から[Server Action](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations)を呼びます

それでは実際にコードを見てみます

### コード ===server-actions-code===

**app/cart_app/page.tsx**
```tsx
async function clearCart() {
  "use server"

  deleteCookie("cart", {cookies})

  revalidatePath("/cart_app")
}

export default async function CartPage() {
  return (
    <div className="my-10 px-4 sm:px-6 lg:px-8">
      <div className="sm:flex sm:items-center">
        <div className="sm:flex-auto">
          <h1 className="demo-h1">複数箇所更新 (ショッピングカート)</h1>
          <CartTechNav selected="server_actions"/>
          <div className="flex justify-between">
            <h2 className="demo-h2">Products</h2>
            <div className="flex">
              <form action={clearCart}>
                <button type="submit"
                        className="p-1 mr-4 border rounded border-orange-600 text-orange-600">Clear
                  Cart
                </button>
              </form>
              <div id="cart_icon">
                <CartIcon />
              </div>
            </div>
          </div>
        </div>
      </div>
      <ProductList />
    </div>
  )
}
```

* Next.js Pages Routerによる実装ではリフトアップのため、`products`、`cart`のデータ取得、さらにイベントハンドラがPageコンポーネントに集中していました。しかしRSCではこれを分散できるので、Pageコンポーネントには`clearCart()`しか残っていません
* `clearCart()`は"use server"宣言があり、Server Componentです。"Clear Cart"ボタンの`form`のactionとして呼び出されています
* `clearCart()`ではcookieをクリアしたのち、キャッシュを入れ替えるための`revalidatePath()`を呼びます。この指示により`/cart_app`のデータはクリアされますが、`/cart_app`のページにいますので、ページが再描画され、データも再度読み込まれます

**app/cart_app/components/CartIcon.tsx**
```tsx
export async function getCart(): Promise<Cart> {
  const cartString = getCookie("cart", {cookies})
  const cart = cartString ? JSON.parse(cartString) : {}

  return cart
}

export default async function CartIcon() {
  const cart = await getCart()

  return (
    <div className="flex items-center">
      ...
      <div className="w-8 text-right text-2xl font-bold">
        {Object.keys(cart).length}
      </div>
    </div>
  )
}
```

* CartIconコンポーネントで`cart`が必要なため、`getCart()`を呼び出しています

**app/cart_app/components/ProductList.tsx**
```tsx
async function getProducts(): Promise<Product[]> {
  const response = await fetch(process.env.URL + "/api/products");
  const products = await response.json();

  return products
}

export default async function ProductList() {
  const products = await getProducts()
  const cart = await getCart()

  return (
    <div className="mt-8 flow-root">
      <div className="-mx-4 -my-2 overflow-x-auto sm:-mx-6 lg:-mx-8">
        <div className="inline-block min-w-full py-2 align-middle sm:px-6 lg:px-8">
          <table className="min-w-full divide-y divide-gray-300">
            ...
            <tbody className="divide-y divide-gray-200 bg-white">
            {
              products.map((product, i) => {
                return (<tr key={i} className="divide-x divide-gray-200">
                  ...
                  <td className="text-center whitespace-nowrap py-4 pl-4 pr-4 text-sm text-gray-500 sm:pr-0">
                    {cart[product.id.toString()]
                        ? <AddedBadge/>
                        : <ProductAddButton product={product}/>}
                  </td>
                </tr>)
              })
            }
            </tbody>
          </table>
        </div>
      </div>
    </div>

  )
}
```

* ProductListコンポーネントでは`products`も`cart`も必要なため、`getProducts()`、`getCart()`を呼び出しています。`getCart()`はCartIconコンポーネントでも呼び出されていましたので、二重に呼び出していますが、影響は小さいので気にしません（colocationを優先させています）

**app/cart_app/components/ProductAddButton.tsx**
```tsx
async function addToCart(formData: FormData) {
  "use server"

  const productId = formData.get("product_id") as string

  const cartString = getCookie("cart", {cookies})
  const cart = cartString ? JSON.parse(cartString) : {}
  cart[productId] = 1

  setCookie("cart", JSON.stringify(cart), {cookies, httpOnly: true})

  revalidatePath("/cart_app")
}


export default function ProductAddButton({product}: { product: Product }) {
  return (<form action={addToCart}>
    <input type="hidden" name="product_id" value={product.id} />
    <button type="submit"
            className="btn-primary border border-orange-600">Add to Cart
    </button>
  </form>)
}
```

* "Add to Cart"ボタンは`form`で囲み、`form`にServer Actionの`addToCart()`を結びつけています。なお`product_id`引数を`addToCart()`に渡す方法として、`<input type="hidden" name="product_id" ../>`を使用しています
* `addToCart()`関数は"use server"があるので、Server Actionになります。`product_id`の情報を引数の`FormData`から取得し、cookieをセットしています
* 最後に`revalidatePath("/cart_app")`を呼び出し、古いデータをブラウザから追い出します。現在のページが`/cart_app`なので、サーバに最新の`/cart_app`ページをリクエストし、レスポンスを画面に表示します
* [`revalidatePath()`](https://nextjs.org/docs/app/building-your-application/caching#revalidatepath)はキャッシュをクリアし、指定されたパス以下のルートを再レンダリングするもので、Server Actionでデータを変更したのちに呼び出します。POST/redirect/GETパターンと異なり、POSTリクエストに対してStatus 200のレスポンスで応答し、ネットワーク通信１往復で済ませることができます

### まとめ ===server-action-summary===

* 常に画面全体をサーバでレンダリングしている点がTurbo Frameに近いと言えます。Turbo Streamsのように変更がある箇所だけを指定して更新したり、Reactのように`cart`だけ更新してCSRしたりなどの最適化はされていませんが、シンプルなコードになっています
* データ更新の時にPOST/redirect/GETではなく、POSTに対してStatus 200で応答し、ネットワーク通信１往復で済ませている点はTurbo Streamsに似ています。処理が少ない通信で完了し、ネットワーク環境が遅くても優れたUI/UXが保てます
*

export default function NewTabbedMenus({children}) {
  return <CommentaryLayout
    title="Multiple Updates (Shopping Cart)"
    subtitle="複数箇所の更新（ショッピングカート）"
    section="Commentary">
    <MDXRenderer>{children}</MDXRenderer>
  </CommentaryLayout>
}
