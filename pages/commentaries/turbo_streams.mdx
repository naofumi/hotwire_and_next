import MDXRenderer from "../../components/MDXRenderer";
import CommentaryLayout from "../../components/CommentaryLayout";
import Image from "next/image"
import cartWithFramesReact from "@/public/images/cart-with-frames-react.webp"
import cartWithTurboStreams from "@/public/images/cart-with-turbo-streams.webp"

## Turbo Streamsは比較的特殊なケースで使う ===use-turbo-streams-for-relatively-special-cases===

Turboには[Turbo Drive, Turbo Frames, Turbo Streamsがあり、適宜使い分ける](/commentaries/tabbed_menus#turbo-ranking)ことは別途紹介しました。またTurbo DriveとTurbo Framesで大半のケースがカバー可能で、Turbo Streamsは比較的特殊なケースで使用するとも述べました。

ただし、Turbo Streamsの方が良いケースは間違いなくあります。またTurbo FramesよりもTurbo Streamsを好み人もいます。

人によって好みが異なる以上、単純にこれがTurbo Streamsの使いどき、あれがTurbo Framesの使いどきを紹介することはできません。そこでここではTurbo Streamsならではの特徴を紹介したいと思います。特徴を理解した上で、適宜判断していただければと思います。

## Turbo Streams固有の機能 ===features-exclusive-to-turbo-streams===

<div className="mt-8 flow-root">
  <div className="-mx-4 -my-2 overflow-x-auto sm:-mx-6 lg:-mx-8">
    <div className="inline-block min-w-full py-2 align-middle sm:px-6 lg:px-8">
      <table className="divide-y divide-gray-300">
        <caption className="caption-top text-left font-bold">Turbo Streams固有の機能</caption>
        <thead>
        <tr>
          <th scope="col" className="py-3.5 pl-4 pr-3 text-left text-sm font-semibold text-gray-900 sm:pl-3">機能</th>
          <th scope="col" className="min-w-28 px-3 py-3.5 text-left text-sm font-semibold text-gray-900">用途</th>
          <th scope="col" className="min-w-80 px-3 py-3.5 text-left text-sm font-semibold text-gray-900">備考</th>
        </tr>
        </thead>
        <tbody className="bg-white">
        <tr className="even:bg-gray-50">
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">Web Socketsに応答</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">Pollingを使わずにリアルタイムで<br />サーバの情報を反映したい時<br />リアルタイムチャットなど</td>
          <td className="px-3 py-4 text-sm text-gray-500"></td>
        </tr>
        <tr className="even:bg-gray-50">
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">部分置換以外の更新</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">置換だけでなく、<br />削除や追加などをしたい時</td>
          <td className="px-3 py-4 text-sm text-gray-500"></td>
        </tr>
        <tr className="even:bg-gray-50">
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">レスポンスを柔軟に<br />指定できる</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">POSTに対して簡素にレスポンスしたい時<br />例えば「いいね」ボタンの実装など</td>
          <td className="px-3 py-4 text-sm text-gray-500">Turbo Framesは`form`からの非GETのリクエストに対して、[POST/Redirect/GETパターン](https://en.wikipedia.org/wiki/Post/Redirect/Get)を前提としいて 、[POST後はstatus 303を期待し、status 200を無視する](https://turbo.hotwired.dev/handbook/drive#redirecting-after-a-form-submission)。これを嫌うときに使う</td>
        </tr>
        <tr className="even:bg-gray-50">
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">画面の複数箇所の更新</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">画面上で離れた箇所を<br />効率的に更新したい時</td>
          <td className="px-3 py-4 text-sm text-gray-500">Turbo Framesで画面の離れた複数箇所を同時更新する時は、全部を覆う大きいTurbo Frameを作る(Reactでいう[stateのリフトアップ](https://ja.react.dev/learn/sharing-state-between-components)と同じ)。一方でTurbo Streamsなら個別に変更できる</td>
        </tr>
        <tr className="even:bg-gray-50">
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">サーバ側から<br />ブラウザを細かく制御</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">状況に応じてレスポンスを返したり、<br />refreshしたりを細かく制御したいとき</td>
          <td className="px-3 py-4 text-sm text-gray-500"></td>
        </tr>
        <tr className="even:bg-gray-50">
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">タグを追加しなくても使える</td>
          <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">&lt;turbo-frame&gt;を差し込めない時</td>
          <td className="px-3 py-4 text-sm text-gray-500"><code>table</code>の中は使用できるタグがHTMLの規約上制限されており、&lt;turbo-frame&gt;が使いにくい</td>
        </tr>
        </tbody>
      </table>
    </div>
  </div>
</div>

以下、（すべては紹介できないかもしれないが）Turbo Streams固有の各機能の使い方を紹介します。

## 画面の複数箇所の更新 ===updating-multiple-segments===

[ショッピングカードの簡単なデモ](/api/hotwire/cart_streams)を用意しています。製品を選択してカートに追加すると、同時に２つのことが起こります。

* "Add to Cart"ボタンが"Added to Cart"バッジに変更される
* 画面右上のカートアイコン(Cart Icon)で追加された品目数が更新される

HotwireおよびNext.jsでこのUIを実現する方法をいくつか検討し、考察していきます。

## Turbo Frames/Reactの考え方（ステートのリフトアップ） ===multi-segment-with-turbo-frames-or-react-concept===

Turbo FramesもReactもステートのリフトアップの発想は同じなので、一緒に紹介します。

"Add to Cart"ボタンとCart Iconは共通の`cart`ステートによって同時に更新されます。製品を新規にカートに追加すれば"Add to Cart"ボタンは"Added to Cart!"バッジになり、Cart Iconでは製品数が1つ増加します。しかし"Add to Cart"ボタンとCart Iconは離れていますので、[ステートのリフトアップ](https://ja.react.dev/learn/sharing-state-between-components#lifting-state-up-by-example)を行います。つまり双方のコンポーネントを内包するより上位のコンポーネントに`cart`ステートを持たせ、更新された時は上位コンポーネント以下を再描画することで、同時更新を実現します。

もちろん無駄が発生します。今回のケースでいうと、他の製品の"Add to Cart"ボタンは全く変更されないのに、再レンダリングされてしまいます。しかし通常は大きな負荷ではなく、またキャッシュなどの方法で最適化も可能なので特に気にしません。Turbo Framesの実装もReactの実装もこの考え方に沿っています。

<figure className="my-4">
  <figcaption className="font-bold">Turbo FramesやReactによる実装方法</figcaption>
  <Image src={cartWithFramesReact} alt="Cart with Turbo Frames and React" />
</figure>

## Turbo Framesによる実装 ===implement-with-turbo-frames===

Turbo Framesの場合は上位コンポーネントとして、"Add to Cart"ボタンとCart Iconを囲む場所に`<turbo-frame id="cart">`タグを配置するだけです。それ以外は普通のMPAと変わりません。[コードはGitHub](https://github.com/naofumi/hotwire_and_next/tree/main/templates/cart_frames)に用意していますので、ご確認ください。

### コード ===turbo-frames-code===

**templates/cart_frames/index.ejs**
```html
<%- include("../layouts/header.ejs") -%>
<div class="my-10 px-4 sm:px-6 lg:px-8">
  <turbo-frame id="cart">
    ...
  </turbo-frame>
</div>
<%- include("../layouts/footer.ejs") -%>
```

* `<turbo-frame id="cart">`で囲むことによって、"Add to Cart"をクリックしたときの動作は`turbo-frame`の中だけに影響するようになります。今回のケースではボタンをクリックしてもスクロール位置が変わらないという効果が得られます（スクロール位置が変わっても良いのであれば、`turbo-frame`で囲む必要すらなく、通常のMPAで十分なUI/UXが実現できます）

**templates/cart_frames/_product_add_button.ejs**
```html
<form method="post" action="/api/hotwire/cart_frames/add_to_cart">
  <input type="hidden" name="product_id" value="<%= product.id %>">
  <button type="submit"
          data-turbo-submits-with="adding..."
          class="btn-primary border border-orange-600">Add to Cart</button>
</form>
```

* "Add to Cart"ボタンは通常の`form`タグで`/api/hotwire/cart_frames/add_to_cart`にPOSTリクエストを投げています（パラメータとして`product_id`も送信）。これはMPAの場合と全く同じです
* 今回はTurbo Framesを使用していますので、`form`はTurboが処理します。そしてレスポンスから`<turbo-frame>`で囲まれているところだけが取り出され、画面の部分更新が行われます

**pages/api/hotwire/cart_frames/add_to_cart.ts**
```ts
// Next.js API route support: https://nextjs.org/docs/api-routes/introduction
import type {NextApiRequest, NextApiResponse} from "next";
import {getCookie, setCookie} from "cookies-next"
import {Cart} from "@/repositories/cart";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  if (req.method !== "POST") { throw new Error("Bad request"); }

  const productId: string = req.body.product_id
  const cartString = getCookie("cart", {req, res})
  const cart: Cart = cartString ? JSON.parse(cartString) : {}

  cart[productId] = 1
  setCookie("cart", JSON.stringify(cart), {res, req})

  res.redirect(303, process.env.URL + "/api/hotwire/cart_frames")
}
```

* `/api/hotwire/cart_frames/add_to_cart`では、`product_id`をcookieに保存します。そして**ここがとても重要なのですが、元のページ`/api/hotwire/cart_frames`にStatus 303のredirectをします**。
* **Redirectすることの大きなメリットはコードが簡単になるということです**。POST後の再描画のコードは全く不要で、元のページを単純に再利用できます。
* Turbo Drive, Turbo Framesを使用する際、`form`タグはブラウザネイティブのものと少し異なる動作をします。特に重要なのは[POST/redirect/GETパターン](https://en.wikipedia.org/wiki/Post/Redirect/Get)が必須となることです。[POSTが成功した場合はStatus 200のレスポンスは無視され、Status 303によるredirectだけが可能になります(Status 302も許容)](https://turbo.hotwired.dev/handbook/drive#redirecting-after-a-form-submission)。Redirectせずに、Status 200で再レンダリングしたHTMLを送ればネットワーク通信が1回減らせますが、それはできないということです。この辺りは分かりにくいので、別途解説予定です。

なおPOST/redirect/GETパターンは古くからベストプラクティスとされていたもので、特に画面リフレッシュ時に同じPOSTを誤って２回送信してしまうのを防ぐ効果がありました。ただしAJAXで非同期通信を行い、URLを変更せずに画面の一部置換を行うUIの場合はこの問題が起こりません。Turbo Drive, Turbo FramesはJavaScriptがオフの場合も動作するように設計されており、おそらくその影響もあって簡便なPOST/redirect/GETパターンを前提としていると考えられます。

### まとめ ===turbo-frames-summary===

* MPAと比べ、`turbo-frame`タグをつけるだけで実装できます
* POST/redirect/GETパターンを使わないといけないので、"Add to Cart"を押してから２回ネットワーク通信が必要になります。ネットワーク遅延が２倍になり、ネットワークが遅い場合はUI/UXへのインパクトが大きくなります

## Reactによる実装 ===implement-multi-segment-with-react===

上述したようにReactによる実装とTurbo Framesによる実装は考え方が似ています。複数箇所を更新するために[ステートをリフトアップ](https://ja.react.dev/learn/sharing-state-between-components#lifting-state-up-by-example)する作戦です。ただしMPAをベースとしてシンプルな改変だけを行うTurbo Framesと比べて、ReactはCSRも使えますので色々な工夫ができます。それを紹介します。

React版は下記の構成になります。

* ショッピングカートUIでは製品情報(`products`)とカート情報(`cart`)の２種類のデータが必要です。Hotwireの場合は完全にSSRなので、サーバで２種のデータを統合します。一方でReactはCSR (Client Side Rendering)を行えますので、ブラウザの中でこの２つを統合し、ブラウザでHTMLをレンダリングできます。今回はこの作戦を採用しました
* サーバ側のSSR (Server Side Rendering)では製品情報(`products`)だけを使って表を描画します。これは初回描画の高速化とSEOに有利にするためです
* SSRのページがブラウザに表示され、Hydrationが完了したのちに、`useEffect`を使ってサーバからカート情報(`cart`)が取得されます。これを使ってCSR (Client Side Rendering)で画面を再レンダリングします
* "Add to Cart"ボタンを押した時はカート情報(`cart`)のみをサーバから取得します。データ取得後、CSRで画面を再描画します

以下、コードを見ていきます([GitHubに掲載](https://github.com/naofumi/hotwire_and_next/tree/main/pages/cart))。[デモ](/cart)はこちらでご確認いただけます。

### コード ===react-code===

**pages/cart/index.tsx**
```tsx
...

export async function getServerSideProps() {
  const response = await fetch(process.env.URL + "/api/products");
  const data = await response.json();

  return {props: {products: data}}
}

export default function CartPage({products}: { products: Product[] }) {
  const [cart, setCart] = useState<Cart | null>(null)

  useEffect(() => {
    fetch("/api/cart")
      .then(response => response.json())
      .then(data => setCart(data))
  }, [])

  function addToCart(productId: number) {
    fetch("/api/cart/add_to_cart", {
      method: "POST",
      headers: {
        "Accept": "application/json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({product_id: productId}),
    }).then(response => response.json())
      .then(data => setCart(data));
  }

  function clearCart() {
    fetch("/api/cart/reset", {
      method: "POST"
    }).then(response => response.json())
      .then(data => setCart(data))
  }

  return (
    <Layout>
      <div className="my-10 px-4 sm:px-6 lg:px-8">
        <div className="sm:flex sm:items-center">
           ...
            <div id="cart_icon">
              {cart
                ? <CartIcon cart={cart}/>
                : <span>Loading...</span>}
            </div>
           ...
        </div>
        <ProductList products={products} cart={cart} addToCart={addToCart} />
      </div>
    </Layout>
  )
}
```

* `products` `cart`のステートはリフトアップされていますので、ステートはすべて`CartPage`コンポーネントが持っています。ステートはpropsで`CartIcon`, `ProductList`コンポーネントに渡されます
* ステートを操作するイベントハンドラの`addToCart()`, `clearCart()`もこのページにリフトアップされる必要があります。この関数もpropsで`CartIcon`, `ProductList`コンポーネントに渡されます
* `useEffect`、`addToCart()`、`clearCart()`はすべて`setCart(data)`でカート情報だけを取得します。`products`を再取得する必要がなくても再レンダリングできるためです
* Turbo Framesの場合は`form`タグを書くだけで、別途イベントハンドラを記載する必要がありませんでした。Reactの場合はイベントハンドラをカスタムで記述する必要があります

### まとめ ===react-summary===

* MPAを少しだけ改変したTurbo Framesの場合と比べると、特にイベントハンドラ周りが複雑になっています
* POST/redirect/GETパターンを使わないので、ネットワーク通信が１回で済みます。その分、レスポンスが高速になり、特にネットワークが遅い場合はUI/UXが優れています
* CSRの特徴を活かして、`products`と`cart`の情報を統合したレンダリングはブラウザで行なっています。おかげで"Add to Cart"ボタンをクリックしたとき、サーバからは`cart`情報のみを取得すれば十分です。ネットワーク負荷、サーバ負荷が減らせます

## Turbo Streamsによる実装 ===implement-turbo-streams===

Turbo Streamsの場合はTurbo Frames, Reactの場合と大きく異なり、ステートのリフトアップは行いません。その代わり、Cart Iconおよび"Add to Cart"ボタンの要素を個別に更新します。Turbo FramesおよびReactの場合は要素更新のロジックは別個に持たず、最初のレンダリングのロジックをそのまま使っていましたが、Turbo Streamsの場合は要素更新ロジックを別途用意する必要があります。

[Turbo Streamsを使った実装のデモ](/api/hotwire/cart_streams)を用意していますのでご覧ください。また[コードはGitHubに載せています](https://github.com/naofumi/hotwire_and_next/tree/main/templates/cart_streams)。

Turbo Streamsを使った場合は、内包する上位のコンポーネントすべてが再レンダリングされるのではなく、"Add to Cart"ボタンとCart Iconのみが再描画されます。

<figure className="my-4">
  <figcaption className="font-bold">Turbo Streamsによる実装方法</figcaption>
  <Image src={cartWithTurboStreams} alt="Cart with Turbo Streams" className="w-1/2 mx-auto" />
</figure>

### コード ===turbo-streams-code===

**pages/api/hotwire/cart_streams/add_to_cart.ts**
```ts
// Next.js API route support: https://nextjs.org/docs/api-routes/introduction
import type {NextApiRequest, NextApiResponse} from "next";
import {render} from "@/helpers/template-renderer"
import {getCookie, setCookie} from "cookies-next"
import {Cart} from "@/repositories/cart";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<string>,
) {
  if (req.method !== "POST") { throw new Error("Bad request"); }

  const productId: string = req.body.product_id
  const cartString = getCookie("cart", {req, res})
  const cart: Cart = cartString ? JSON.parse(cartString) : {}

  cart[productId] = 1
  setCookie("cart", JSON.stringify(cart), {res, req})

  const resultText = render("cart_streams/add_to_cart.ejs",
    {productId, cart}
  )

  res.appendHeader("Content-Type", "text/vnd.turbo-stream.html")
    .status(200)
    .send(resultText)
}
```

* Turbo Streamsの場合は(当然ではありますが)`<turbo-frame>`タグが不要なので、削除してあります (つまりMPAの状態まず戻します)
* 変更があるのは `pages/api/hotwire/cart_streams/add_to_cart.ts`と`templates/cart_streams/add_to_cart.ejs` – つまりカートに製品を追加し、画面を更新するところです
* 上記の`pages/api/hotwire/cart_streams/add_to_cart.ts`では`product_id`をcookieに保存後、`cart_streams/add_to_cart.ejs`テンプレートファイルを`Content-Type: text/vnd.turbo-stream.html`でブラウザに送信しています。Turbo Framesの場合、ここはStatus 303のredirectでした

**templates/cart_streams/add_to_cart.ejs**

```html
<turbo-stream action="update" target="<%= `product_${productId}` %>">
  <template>
    <%- include("_added_badge.ejs") %>
  </template>
</turbo-stream>

<turbo-stream action="update" target="cart_icon">
  <template>
    <%- include("_cart_icon.ejs", {cart}) %>
  </template>
</turbo-stream>
```

* `pages/api/hotwire/cart_streams/add_to_cart.ts`は"Add to Cart"ボタンとCart Iconをそれぞれ別個に更新する指示です。上の`turbo-stream`が"Add to Cart"ボタンの箇所、下の`turbo-stream`がCart Iconの箇所になります
* `target=`属性を使って、更新先の要素の`id`を指定します。
* レスポンスのheaderの`Content-Type: text/vnd.turbo-stream.html`を見て、ブラウザはこれがTurbo Stream応答であることを知ります。そして上記の２つの`turbo-stream`を適宜処理して、画面を更新します

### まとめ ===summary-turbo-streams===

* Turbo Framesに比べて更新箇所を細かく指定できます。余計な箇所を再レンダリングしません
* これを実現するために、「何をどのように更新するか」を指示しています。`<turbo-stream>`タグを使って宣言的に記述するため、ロジックはゴチャつきにくくなっています。それでもTurbo FramesやReactの場合はそもそも更新ロジックの記載が不要だったことを考えると、複雑になっています
* 更新ロジックが単純な場合は問題ありませんが、複雑になると場合はTurbo FramesもしくはMorphingを使って、更新ロジックそのものを不要にした方が良いでしょう

## React Server Actionsによる実装 ===implement-server-actions===

TurboはSSRですが、上記に紹介したReactはSSRとCSRの組み合わせでした。ここではReactでSSRだけを使った場合にどうなるかを見るために、React Server Actionsによる実装を確認します。

export default function NewTabbedMenus({children}) {
  return <CommentaryLayout
    title="Multiple Updates (Shopping Cart)"
    subtitle="複数箇所の更新（ショッピングカート）"
    section="Commentary">
    <MDXRenderer>{children}</MDXRenderer>
  </CommentaryLayout>
}
