# TurboFrames: タブメニュー

## ウェブサイトのUIは「枠」が重要

ウェブサイトのUIは「枠」で作られることが多い。

例えばインタラクティブなUIの代表である「モーダル」は、画面上に「枠」を出現させ、その中にUI要素を詰めていると考えることができる。「ポップアップダイアログ」や「ドロップダウンメニュー」も同様である。 タブメニューも、どのタブをクリックするかによって「枠」の中身を切り替えるものである。

このように a) 「枠」の表示・非表示を切り替え、b) その中身を自在に出し入れできれば、かなり多くのウェブUI要素を作ることができる。TurboFramesはこのうちの後者をパッケージ化したものである。

## TurboFramesは「枠」のデータをサーバから取ってきて、はめ込む

「枠」そのものは簡単なJavaScriptで表示・非表示を切り替えることができる。具体的には、Reactなら`useState`で表示・非表示用のステートを作り、内容に応じて「枠」コンポーネントをレンダリングするかどうかを切り替えるだろう。また `style`の`display:none`を切り替えればもっと簡単に表示・非表示を切り替えられる。

したがって「枠」の内容がすでにブラウザにあればシンプルである。 問題は「枠」の内容をサーバから取得するところである。

TurboFramesはここを担う。

### TurboFramesにデータを読み込ませる方法

TurboFrameそのものは、画面の任意の箇所に`<turbo-frame id=".."></turbo-frame>`を挿入することで作成できる。このTurboFrameにデータを読み込ませる方法はいくつか用意されている。(詳細は[公式ページ](https://turbo.hotwired.dev/reference/frames))

1. **データの取得先を`src`属性で指定する方法:** `<turbo-frame src="location" id="..."></turbo-frame>`などとかいて、`src`属性で指定されたエンドポイントからデータを入手し、これをTurboFrameに挿入することができる
2. **a tagの`data-turbo-frame`属性で指定する方法:** `<a href="location" data-turbo-frame=".."/>..</a>`とすることで、`href`属性に指定されたエンドポイントからデータを入手し、これをTurboFrameに挿入することができる
3. **TurboFrameの中のa tagやform tagを使う方法:** TurboFrameの中の`a tag`や`form tag`のエンドポイントから得られたデータは、デフォルトではそのTurboFrameに挿入される
4. **JavaScriptで指定する方法:** `Turbo.visit(location, {frame: frame})`を実行すると、エンドポイントから得られたデータは指定されたTurboFrameに挿入される

これらを適切に使用することで、ほとんどのシチュエーションに対応できるようになる。

なおエンドポイントのコンテンツのうち、TurboFrameに挿入したいものは必ず`<turbo-frame id="...">...</turbo-frame>`で囲む必要がある。Hotwireはエンドポイントをなるべく使い回せるように設計されているためである。

## TurboFramesによるタブメニュー実装

タブメニューをTurboFramesで実装した場合の処理は下記の通りである。

1. タブメニューのボタン(`Products`)ボタンがクリックされる(`a tag`)
2. `a tag`をクリックすると通常は画面遷移をするが、`data-turbo-frame`属性があるので、代わりに非同期で`products`のエンドポイントにGETリクエストを飛ばす
3. サーバは適切なレスポンスを返す。この中にはTurboFrames「枠」に差し込むべきHTMLが含まれる(`<turbo-frame>`に囲まれている)
4. `<turbo-frame>`に囲まれているコンテンツを対応するTurboFrames「枠」に差し込む

まず最初にエンドポイントからHTMLを取得しに行き、それをTurboFrameに差し込むというイメージである。

## Reactだったらどうするか

比較のために、Reactで作った場合の動作も確認する

1. タブメニューのボタン(`Products`)がクリックされる
2. ボタンの`onClick`属性で指定されたハンドラー関数を呼び出す。このハンドラー関数により、どのタブが指定されているかのステート(`selectedTab`)を更新する
3. 再レンダリングが行われ、`selectedTab`の内容に応じて、タブの中身のコンポーネントを切り替える(`Users` => `Products`)
4. `Products`コンポーネントがレンダリングされる
5. `Products`コンポーネントはこの時点ではサーバのデータを持っていない。レンダリング後に`useEffect`の中が実行され、サーバから商品データが取得される。このデータで`Products`のステートを更新する
6. 再レンダリングが実行され、`Products`コンポーネントに商品データが正しく表示される

Reactの場合は、まずタブの中身を`Products`コンポーネントに入れ替える（ブラウザの中で）。`Products`コンポーネントは自分自身がどのようにデータを取得するべきかを知っているので、`useEffect`の中でそれを実行している。

HotwireはTurboFrameコンテンツをただのHTML文字列として扱っているのに対して、Reactでは`Products`コンポーネント自身がメソッドとデータを持つオブジェクトのように振る舞う。

## TurboFramesでは、画面遷移と画面部分更新で同じactionを使う

* Next.jsでServer Component/Streamingやると、画面遷移の時はserver側の関数を読み込んでデータを取得する –– あるいはuseEffectを使う
* Turboの場合はTurboDriveとTurboFramesで使うテンプレートやactionはにできる

## 開発の流れ

TurboFramesの場合は、タブの中に差し込むコンテンツは独立したエンドポイントである。ブラウザをそのURLに向ければ、そのコンテンツがそのまま表示される。

このため、開発時にはまずこのエンドポイントのHTMLレスポンスを作るところから始める。その後にTurboFramesの枠をはめて、また呼び出し側で受け入れるためのTurboFramesを設置する。最後にこのエンドポイントに向かう`a tag`を作る(このタグの属性として`data-turbo-frame`で対象のTurboFrameのIDを指定する)

## TurboFramesはa tag, form tagの拡張

Reactの処理は`a tag`と無関係であり、`a tag`は全く使われない。一方でTurboFramesの場合は`a tag`の機能を拡張しているだけに見える。

`a tag`に`target="_blank"`属性を付与すると、ブラウザのネイティブな機能としてレスポンスは新規タブに表示される。TurboFrameの動きはこれに酷似していて、ブラウザタブをTurboFrameに置き換えているだけだ。

`a tag`の拡張であることを示すもう一つの例として、TurboFrameのエンドポイントをブラウザの検索バーに表示させ、ブラウザの履歴に保存したり、ブックマークしたり、バックボタンを効かせたりもできる。今回のデモでもそのようになっているので、URLが変わること、検索バーの表示内容が変更され、バックボタンが効くことなどを確認できる。

Reactの場合はタブの中身とURLは完全に独立した考えになっているので、このような動きにはならない。なおapp routerのネスト化されたルートは少しTurboFramesの考え方に近く、画面の一部とURLを連動できるようになっている。

## リンクのprefetch

TurboFramesは`a tag`を拡張しているだけなので、通常通りにprefetchが機能する。そのためタブをクリックしたときのレスポンスは良好である。

一方でReactの場合は、タブは`Link tag`ではない。そのためprefetchは機能しない。コンポーネントを切り替えるところまではブラウザ内で処理されるので瞬間的だが、`useEffect`内の`fetch`リクエストはprefetchされないので高速化されない。

